// Generated by Sideko (sideko.dev)
import * as fs from "fs";
import axios, { AxiosInstance, ResponseType } from "axios";
import * as FormData from "form-data";

import { Convert,  DeleteApisAPIIDResponse401,  DeleteApisAPIIDResponse403,  DeleteApisAPIIDResponse404,  DeleteApisAPIIDResponse422,  DeleteApisAPIIDResponse500,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422,  DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500,  DeleteApisAPIIDVersionsVersionIDResponse400,  DeleteApisAPIIDVersionsVersionIDResponse400Error,  DeleteApisAPIIDVersionsVersionIDResponse401,  DeleteApisAPIIDVersionsVersionIDResponse403,  DeleteApisAPIIDVersionsVersionIDResponse404,  DeleteApisAPIIDVersionsVersionIDResponse500,  DeleteCollectionsCollectionIDFoldersFolderIDResponse,  DeleteCollectionsCollectionIDFoldersFolderIDResponseData,  DeleteCollectionsCollectionIDFoldersFolderIDResponse401,  DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error,  DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails,  DeleteCollectionsCollectionIDFoldersFolderIDResponse404,  DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error,  DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails,  DeleteCollectionsCollectionIDFoldersFolderIDResponse500,  DeleteCollectionsCollectionIDRequestsRequestIDResponse,  DeleteCollectionsCollectionIDRequestsRequestIDResponseData,  DeleteCollectionsCollectionIDRequestsRequestIDResponse401,  DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error,  DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails,  DeleteCollectionsCollectionIDRequestsRequestIDResponse404,  DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error,  DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails,  DeleteCollectionsCollectionIDRequestsRequestIDResponse500,  DeleteCollectionsCollectionIDResponse,  DeleteCollectionsCollectionIDResponseCollection,  DeleteCollectionsCollectionIDResponse401,  DeleteCollectionsCollectionIDResponse401Error,  DeleteCollectionsCollectionIDResponse404,  DeleteCollectionsCollectionIDResponse404Error,  DeleteCollectionsCollectionIDResponse404ErrorDetails,  DeleteCollectionsCollectionIDResponse429,  DeleteCollectionsCollectionIDResponse500,  DeleteCollectionsCollectionIDResponse500Error,  DeleteCollectionsCollectionIDResponsesResponseIDResponse,  DeleteCollectionsCollectionIDResponsesResponseIDResponseData,  DeleteCollectionsCollectionIDResponsesResponseIDResponse401,  DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error,  DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails,  DeleteCollectionsCollectionIDResponsesResponseIDResponse404,  DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error,  DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails,  DeleteCollectionsCollectionIDResponsesResponseIDResponse500,  DeleteEnvironmentsEnvironmentIDResponse,  DeleteEnvironmentsEnvironmentIDResponseEnvironment,  DeleteEnvironmentsEnvironmentIDResponse401,  DeleteEnvironmentsEnvironmentIDResponse401Error,  DeleteEnvironmentsEnvironmentIDResponse404,  DeleteEnvironmentsEnvironmentIDResponse404Error,  DeleteEnvironmentsEnvironmentIDResponse429,  DeleteEnvironmentsEnvironmentIDResponse500,  DeleteEnvironmentsEnvironmentIDResponse500Error,  DeleteMocksMockIDResponse,  DeleteMocksMockIDResponseMock,  DeleteMocksMockIDResponse400,  DeleteMocksMockIDResponse400Error,  DeleteMocksMockIDResponse401,  DeleteMocksMockIDResponse401Error,  DeleteMocksMockIDResponse404,  DeleteMocksMockIDResponse404Error,  DeleteMocksMockIDResponse429,  DeleteMocksMockIDResponse500,  DeleteMocksMockIDResponse500Error,  DeleteMocksMockIDServerResponsesServerResponseIDResponse,  DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem,  DeleteMocksMockIDServerResponsesServerResponseIDResponse400,  DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error,  DeleteMocksMockIDServerResponsesServerResponseIDResponse401,  DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error,  DeleteMocksMockIDServerResponsesServerResponseIDResponse404,  DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error,  DeleteMocksMockIDServerResponsesServerResponseIDResponse429,  DeleteMocksMockIDServerResponsesServerResponseIDResponse500,  DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error,  DeleteMocksMockIDUnpublishResponse,  DeleteMocksMockIDUnpublishResponseMock,  DeleteMocksMockIDUnpublishResponse400,  DeleteMocksMockIDUnpublishResponse400Error,  DeleteMocksMockIDUnpublishResponse401,  DeleteMocksMockIDUnpublishResponse401Error,  DeleteMocksMockIDUnpublishResponse404,  DeleteMocksMockIDUnpublishResponse404Error,  DeleteMocksMockIDUnpublishResponse429,  DeleteMocksMockIDUnpublishResponse500,  DeleteMocksMockIDUnpublishResponse500Error,  DeleteMonitorsMonitorIDResponse,  DeleteMonitorsMonitorIDResponseMonitor,  DeleteMonitorsMonitorIDResponse400,  DeleteMonitorsMonitorIDResponse400Error,  DeleteMonitorsMonitorIDResponse401,  DeleteMonitorsMonitorIDResponse401Error,  DeleteMonitorsMonitorIDResponse429,  DeleteMonitorsMonitorIDResponse500,  DeleteMonitorsMonitorIDResponse500Error,  DeleteNetworkPrivateElementTypeElementIDResponse,  DeleteNetworkPrivateElementTypeElementIDResponseElementType,  DeleteNetworkPrivateElementTypeElementIDResponse400,  DeleteNetworkPrivateElementTypeElementIDResponse401,  DeleteNetworkPrivateElementTypeElementIDResponse401Error,  DeleteNetworkPrivateElementTypeElementIDResponse403,  DeleteNetworkPrivateElementTypeElementIDResponse403Error,  DeleteNetworkPrivateElementTypeElementIDResponse404,  DeleteNetworkPrivateElementTypeElementIDResponse404Error,  DeleteNetworkPrivateElementTypeElementIDResponse429,  DeleteNetworkPrivateElementTypeElementIDResponse500,  DeleteNetworkPrivateElementTypeElementIDResponse500Error,  DeleteScimV2GroupsGroupIDResponse400,  DeleteScimV2GroupsGroupIDResponse401,  DeleteScimV2GroupsGroupIDResponse403,  DeleteScimV2GroupsGroupIDResponse404,  DeleteScimV2GroupsGroupIDResponse429,  DeleteScimV2GroupsGroupIDResponse500,  DeleteWorkspacesWorkspaceIDResponse,  DeleteWorkspacesWorkspaceIDResponseWorkspace,  DeleteWorkspacesWorkspaceIDResponse400,  DeleteWorkspacesWorkspaceIDResponse400Error,  DeleteWorkspacesWorkspaceIDResponse401,  DeleteWorkspacesWorkspaceIDResponse401Error,  DeleteWorkspacesWorkspaceIDResponse429,  DeleteWorkspacesWorkspaceIDResponse500,  DeleteWorkspacesWorkspaceIDResponse500Error,  GetApisAPIIDCollectionsCollectionIDResponse,  GetApisAPIIDCollectionsCollectionIDResponseInfo,  GetApisAPIIDCollectionsCollectionIDResponseItemItem,  GetApisAPIIDCollectionsCollectionIDResponse400,  GetApisAPIIDCollectionsCollectionIDResponse401,  GetApisAPIIDCollectionsCollectionIDResponse403,  GetApisAPIIDCollectionsCollectionIDResponse404,  GetApisAPIIDCollectionsCollectionIDResponse500,  GetApisAPIIDResponse401,  GetApisAPIIDResponse404,  GetApisAPIIDResponse422,  GetApisAPIIDResponse500,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422,  GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500,  GetApisAPIIDSchemasSchemaIDFilesResponse,  GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem,  GetApisAPIIDSchemasSchemaIDFilesResponseMeta,  GetApisAPIIDSchemasSchemaIDFilesResponse400,  GetApisAPIIDSchemasSchemaIDFilesResponse401,  GetApisAPIIDSchemasSchemaIDFilesResponse404,  GetApisAPIIDSchemasSchemaIDFilesResponse422,  GetApisAPIIDSchemasSchemaIDFilesResponse500,  GetApisAPIIDSchemasSchemaIDResponse400,  GetApisAPIIDSchemasSchemaIDResponse401,  GetApisAPIIDSchemasSchemaIDResponse403,  GetApisAPIIDSchemasSchemaIDResponse404,  GetApisAPIIDSchemasSchemaIDResponse422,  GetApisAPIIDSchemasSchemaIDResponse500,  GetApisAPIIDTagsResponse,  GetApisAPIIDTagsResponseTagsItem,  GetApisAPIIDTagsResponse401,  GetApisAPIIDTagsResponse403,  GetApisAPIIDTagsResponse404,  GetApisAPIIDTagsResponse500,  GetApisAPIIDTasksTaskIDResponse,  GetApisAPIIDTasksTaskIDResponseMeta,  GetApisAPIIDTasksTaskIDResponse400,  GetApisAPIIDTasksTaskIDResponse401,  GetApisAPIIDTasksTaskIDResponse403,  GetApisAPIIDTasksTaskIDResponse404,  GetApisAPIIDVersionsResponse,  GetApisAPIIDVersionsResponseMeta,  GetApisAPIIDVersionsResponseVersionsItem,  GetApisAPIIDVersionsResponse401,  GetApisAPIIDVersionsResponse404,  GetApisAPIIDVersionsResponse422,  GetApisAPIIDVersionsResponse500,  GetApisAPIIDVersionsVersionIDResponse,  GetApisAPIIDVersionsVersionIDResponseVersion,  GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem,  GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem,  GetApisAPIIDVersionsVersionIDResponse401,  GetApisAPIIDVersionsVersionIDResponse404,  GetApisAPIIDVersionsVersionIDResponse500,  GetApisResponse,  GetApisResponseApisItem,  GetApisResponseMeta,  GetApisResponse401,  GetApisResponse401Error,  GetApisResponse404,  GetApisResponse422,  GetApisResponse500,  GetAuditLogsResponse,  GetAuditLogsResponseTrailsItem,  GetAuditLogsResponseTrailsItemData,  GetAuditLogsResponseTrailsItemDataActor,  GetAuditLogsResponseTrailsItemDataTeam,  GetAuditLogsResponseTrailsItemDataUser,  GetAuditLogsResponse401,  GetAuditLogsResponse401Error,  GetAuditLogsResponse429,  GetAuditLogsResponse500,  GetAuditLogsResponse500Error,  GetCollectionsCollectionIDFoldersFolderIDResponse,  GetCollectionsCollectionIDFoldersFolderIDResponseData,  GetCollectionsCollectionIDFoldersFolderIDResponse401,  GetCollectionsCollectionIDFoldersFolderIDResponse401Error,  GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails,  GetCollectionsCollectionIDFoldersFolderIDResponse404,  GetCollectionsCollectionIDFoldersFolderIDResponse404Error,  GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails,  GetCollectionsCollectionIDFoldersFolderIDResponse500,  GetCollectionsCollectionIDRequestsRequestIDResponse,  GetCollectionsCollectionIDRequestsRequestIDResponseData,  GetCollectionsCollectionIDRequestsRequestIDResponse401,  GetCollectionsCollectionIDRequestsRequestIDResponse401Error,  GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails,  GetCollectionsCollectionIDRequestsRequestIDResponse404,  GetCollectionsCollectionIDRequestsRequestIDResponse404Error,  GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails,  GetCollectionsCollectionIDRequestsRequestIDResponse500,  GetCollectionsCollectionIDResponse,  GetCollectionsCollectionIDResponseCollection,  GetCollectionsCollectionIDResponseCollectionInfo,  GetCollectionsCollectionIDResponse400,  GetCollectionsCollectionIDResponse400Error,  GetCollectionsCollectionIDResponse401,  GetCollectionsCollectionIDResponse401Error,  GetCollectionsCollectionIDResponse429,  GetCollectionsCollectionIDResponse500,  GetCollectionsCollectionIDResponse500Error,  GetCollectionsCollectionIDResponsesResponseIDResponse,  GetCollectionsCollectionIDResponsesResponseIDResponseData,  GetCollectionsCollectionIDResponsesResponseIDResponse401,  GetCollectionsCollectionIDResponsesResponseIDResponse401Error,  GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails,  GetCollectionsCollectionIDResponsesResponseIDResponse404,  GetCollectionsCollectionIDResponsesResponseIDResponse404Error,  GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails,  GetCollectionsCollectionIDResponsesResponseIDResponse500,  GetCollectionsCollectionIDTagsResponse,  GetCollectionsCollectionIDTagsResponseTagsItem,  GetCollectionsCollectionIDTagsResponse401,  GetCollectionsCollectionIDTagsResponse403,  GetCollectionsCollectionIDTagsResponse500,  GetCollectionsCollectionIDTransformationsResponse,  GetCollectionsCollectionIDTransformationsResponse401,  GetCollectionsCollectionIDTransformationsResponse404,  GetCollectionsCollectionIDTransformationsResponse500,  GetCollectionsResponse,  GetCollectionsResponseCollectionsItem,  GetCollectionsResponseCollectionsItemFork,  GetCollectionsResponse401,  GetCollectionsResponse401Error,  GetCollectionsResponse429,  GetCollectionsResponse500,  GetCollectionsResponse500Error,  GetDetectedSecretsSecretIDLocationsResponse,  GetDetectedSecretsSecretIDLocationsResponseDataItem,  GetDetectedSecretsSecretIDLocationsResponseMeta,  GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem,  GetDetectedSecretsSecretIDLocationsResponse400,  GetDetectedSecretsSecretIDLocationsResponse401,  GetDetectedSecretsSecretIDLocationsResponse403,  GetDetectedSecretsSecretIDLocationsResponse500,  GetEnvironmentsEnvironmentIDResponse,  GetEnvironmentsEnvironmentIDResponseEnvironment,  GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem,  GetEnvironmentsEnvironmentIDResponse400,  GetEnvironmentsEnvironmentIDResponse400Error,  GetEnvironmentsEnvironmentIDResponse401,  GetEnvironmentsEnvironmentIDResponse401Error,  GetEnvironmentsEnvironmentIDResponse429,  GetEnvironmentsEnvironmentIDResponse500,  GetEnvironmentsEnvironmentIDResponse500Error,  GetEnvironmentsResponse,  GetEnvironmentsResponseEnvironmentsItem,  GetEnvironmentsResponse401,  GetEnvironmentsResponse401Error,  GetEnvironmentsResponse404,  GetEnvironmentsResponse404Error,  GetEnvironmentsResponse429,  GetEnvironmentsResponse500,  GetEnvironmentsResponse500Error,  GetMeResponse,  GetMeResponseOperationsItem,  GetMeResponseUser,  GetMeResponse401,  GetMeResponse401Error,  GetMeResponse429,  GetMeResponse500,  GetMeResponse500Error,  GetMocksMockIDCallLogsResponse,  GetMocksMockIDCallLogsResponseCallLogsItem,  GetMocksMockIDCallLogsResponseCallLogsItemRequest,  GetMocksMockIDCallLogsResponseCallLogsItemRequestBody,  GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders,  GetMocksMockIDCallLogsResponseCallLogsItemResponse,  GetMocksMockIDCallLogsResponseCallLogsItemResponseBody,  GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders,  GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription,  GetMocksMockIDCallLogsResponseMeta,  GetMocksMockIDCallLogsResponse400,  GetMocksMockIDCallLogsResponse400Error,  GetMocksMockIDCallLogsResponse401,  GetMocksMockIDCallLogsResponse401Error,  GetMocksMockIDCallLogsResponse404,  GetMocksMockIDCallLogsResponse404Error,  GetMocksMockIDCallLogsResponse429,  GetMocksMockIDCallLogsResponse500,  GetMocksMockIDCallLogsResponse500Error,  GetMocksMockIDResponse,  GetMocksMockIDResponseMock,  GetMocksMockIDResponseMockConfig,  GetMocksMockIDResponse401,  GetMocksMockIDResponse401Error,  GetMocksMockIDResponse404,  GetMocksMockIDResponse404Error,  GetMocksMockIDResponse429,  GetMocksMockIDResponse500,  GetMocksMockIDResponse500Error,  GetMocksMockIDServerResponsesResponse401,  GetMocksMockIDServerResponsesResponse401Error,  GetMocksMockIDServerResponsesResponse404,  GetMocksMockIDServerResponsesResponse404Error,  GetMocksMockIDServerResponsesResponse429,  GetMocksMockIDServerResponsesResponse500,  GetMocksMockIDServerResponsesResponse500Error,  GetMocksMockIDServerResponsesResponseItem,  GetMocksMockIDServerResponsesServerResponseIDResponse400,  GetMocksMockIDServerResponsesServerResponseIDResponse400Error,  GetMocksMockIDServerResponsesServerResponseIDResponse401,  GetMocksMockIDServerResponsesServerResponseIDResponse401Error,  GetMocksMockIDServerResponsesServerResponseIDResponse404,  GetMocksMockIDServerResponsesServerResponseIDResponse404Error,  GetMocksMockIDServerResponsesServerResponseIDResponse429,  GetMocksMockIDServerResponsesServerResponseIDResponse500,  GetMocksMockIDServerResponsesServerResponseIDResponse500Error,  GetMocksMockIDServerResponsesServerResponseIDResponseItem,  GetMocksResponse,  GetMocksResponseMocksItem,  GetMocksResponseMocksItemConfig,  GetMocksResponseMocksItemConfigDelay,  GetMocksResponse401,  GetMocksResponse401Error,  GetMocksResponse429,  GetMocksResponse500,  GetMocksResponse500Error,  GetMonitorsMonitorIDResponse,  GetMonitorsMonitorIDResponseMonitor,  GetMonitorsMonitorIDResponseMonitorLastRun,  GetMonitorsMonitorIDResponseMonitorLastRunStats,  GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions,  GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests,  GetMonitorsMonitorIDResponseMonitorNotifications,  GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem,  GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem,  GetMonitorsMonitorIDResponseMonitorOptions,  GetMonitorsMonitorIDResponseMonitorSchedule,  GetMonitorsMonitorIDResponse401,  GetMonitorsMonitorIDResponse401Error,  GetMonitorsMonitorIDResponse404,  GetMonitorsMonitorIDResponse404Error,  GetMonitorsMonitorIDResponse429,  GetMonitorsMonitorIDResponse500,  GetMonitorsMonitorIDResponse500Error,  GetMonitorsResponse,  GetMonitorsResponseMonitorsItem,  GetMonitorsResponse401,  GetMonitorsResponse401Error,  GetMonitorsResponse429,  GetMonitorsResponse500,  GetMonitorsResponse500Error,  GetNetworkPrivateNetworkEntityRequestAllResponse,  GetNetworkPrivateNetworkEntityRequestAllResponseMeta,  GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem,  GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement,  GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse,  GetNetworkPrivateNetworkEntityRequestAllResponse400,  GetNetworkPrivateNetworkEntityRequestAllResponse401,  GetNetworkPrivateNetworkEntityRequestAllResponse401Error,  GetNetworkPrivateNetworkEntityRequestAllResponse403,  GetNetworkPrivateNetworkEntityRequestAllResponse403Error,  GetNetworkPrivateNetworkEntityRequestAllResponse429,  GetNetworkPrivateNetworkEntityRequestAllResponse500,  GetNetworkPrivateNetworkEntityRequestAllResponse500Error,  GetNetworkPrivateResponse,  GetNetworkPrivateResponseElementsItem,  GetNetworkPrivateResponseFoldersItem,  GetNetworkPrivateResponseMeta,  GetNetworkPrivateResponse401,  GetNetworkPrivateResponse401Error,  GetNetworkPrivateResponse403,  GetNetworkPrivateResponse403Error,  GetNetworkPrivateResponse429,  GetNetworkPrivateResponse500,  GetNetworkPrivateResponse500Error,  GetScimV2GroupsGroupIDResponse,  GetScimV2GroupsGroupIDResponseMembers,  GetScimV2GroupsGroupIDResponseMeta,  GetScimV2GroupsGroupIDResponse400,  GetScimV2GroupsGroupIDResponse401,  GetScimV2GroupsGroupIDResponse403,  GetScimV2GroupsGroupIDResponse404,  GetScimV2GroupsGroupIDResponse429,  GetScimV2GroupsGroupIDResponse500,  GetScimV2GroupsResponse,  ScimGroupResource,  ScimGroupResourceMembers,  ScimGroupResourceMeta,  GetScimV2GroupsResponse400,  GetScimV2GroupsResponse401,  GetScimV2GroupsResponse403,  GetScimV2GroupsResponse429,  GetScimV2GroupsResponse500,  GetScimV2ResourceTypesResponse401,  GetScimV2ResourceTypesResponse401Error,  GetScimV2ResourceTypesResponse500,  GetScimV2ResourceTypesResponseItem,  GetScimV2ResourceTypesResponseItemSchemaExtensionsItem,  GetScimV2ServiceProviderConfigResponse,  GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem,  GetScimV2ServiceProviderConfigResponseBulk,  GetScimV2ServiceProviderConfigResponseChangePassword,  GetScimV2ServiceProviderConfigResponseEtag,  GetScimV2ServiceProviderConfigResponseFilter,  GetScimV2ServiceProviderConfigResponseMeta,  GetScimV2ServiceProviderConfigResponsePatch,  GetScimV2ServiceProviderConfigResponseSort,  GetScimV2ServiceProviderConfigResponse401,  GetScimV2ServiceProviderConfigResponse500,  GetScimV2UsersResponse,  ScimUserResource,  ScimUserResourceMeta,  ScimUserResourceName,  GetScimV2UsersResponse400,  GetScimV2UsersResponse401,  GetScimV2UsersResponse403,  GetScimV2UsersResponse429,  GetScimV2UsersResponse500,  GetScimV2UsersUserIDResponse,  GetScimV2UsersUserIDResponseMeta,  GetScimV2UsersUserIDResponseName,  GetScimV2UsersUserIDResponse400,  GetScimV2UsersUserIDResponse401,  GetScimV2UsersUserIDResponse403,  GetScimV2UsersUserIDResponse404,  GetScimV2UsersUserIDResponse429,  GetScimV2UsersUserIDResponse500,  GetSecretTypesResponse,  GetSecretTypesResponseDataItem,  GetSecretTypesResponseMeta,  GetSecretTypesResponse401,  GetSecretTypesResponse403,  GetSecretTypesResponse500,  GetTagsSlugEntitiesResponse,  GetTagsSlugEntitiesResponseData,  GetTagsSlugEntitiesResponseDataEntitiesItem,  GetTagsSlugEntitiesResponseMeta,  GetTagsSlugEntitiesResponse400,  GetTagsSlugEntitiesResponse401,  GetTagsSlugEntitiesResponse403,  GetTagsSlugEntitiesResponse404,  GetTagsSlugEntitiesResponse500,  GetWorkspacesResponse,  GetWorkspacesResponseWorkspacesItem,  GetWorkspacesResponse401,  GetWorkspacesResponse401Error,  GetWorkspacesResponse429,  GetWorkspacesResponse500,  GetWorkspacesResponse500Error,  GetWorkspacesWorkspaceIDGlobalVariablesResponse,  GlobalVariable,  GetWorkspacesWorkspaceIDGlobalVariablesResponse500,  GetWorkspacesWorkspaceIDResponse,  GetWorkspacesWorkspaceIDResponseWorkspace,  GetWorkspacesWorkspaceIDResponseWorkspaceApisItem,  GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem,  GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem,  GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem,  GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem,  GetWorkspacesWorkspaceIDResponse401,  GetWorkspacesWorkspaceIDResponse401Error,  GetWorkspacesWorkspaceIDResponse404,  GetWorkspacesWorkspaceIDResponse404Error,  GetWorkspacesWorkspaceIDResponse429,  GetWorkspacesWorkspaceIDResponse500,  GetWorkspacesWorkspaceIDResponse500Error,  GetWorkspacesWorkspaceIDTagsResponse,  GetWorkspacesWorkspaceIDTagsResponseTagsItem,  GetWorkspacesWorkspaceIDTagsResponse401,  GetWorkspacesWorkspaceIDTagsResponse403,  GetWorkspacesWorkspaceIDTagsResponse404,  GetWorkspacesWorkspaceIDTagsResponse500,  PANElementCreated,  PANFolderCreated,  PatchCollectionsCollectionIDBody,  PatchCollectionsCollectionIDBodyCollection,  PatchCollectionsCollectionIDBodyCollectionInfo,  PatchCollectionsCollectionIDResponse,  PatchCollectionsCollectionIDResponseCollection,  PatchCollectionsCollectionIDResponse400,  PatchCollectionsCollectionIDResponse400Error,  PatchCollectionsCollectionIDResponse401,  PatchCollectionsCollectionIDResponse401Error,  PatchCollectionsCollectionIDResponse403,  PatchCollectionsCollectionIDResponse403Error,  PatchCollectionsCollectionIDResponse404,  PatchCollectionsCollectionIDResponse404Error,  PatchCollectionsCollectionIDResponse404ErrorDetails,  PatchCollectionsCollectionIDResponse429,  PatchCollectionsCollectionIDResponse500,  PatchCollectionsCollectionIDResponse500Error,  PatchScimV2GroupsGroupIDBody,  PatchScimV2GroupsGroupIDBodyOperationsItem,  PatchScimV2GroupsGroupIDBodyOperationsItemValue,  PatchScimV2GroupsGroupIDResponse,  PatchScimV2GroupsGroupIDResponseMeta,  PatchScimV2GroupsGroupIDResponse400,  PatchScimV2GroupsGroupIDResponse401,  PatchScimV2GroupsGroupIDResponse403,  PatchScimV2GroupsGroupIDResponse404,  PatchScimV2GroupsGroupIDResponse429,  PatchScimV2GroupsGroupIDResponse500,  PatchScimV2UsersUserIDBody,  PatchScimV2UsersUserIDBodyOperationsItem,  PatchScimV2UsersUserIDBodyOperationsItemValue,  PatchScimV2UsersUserIDResponse,  PatchScimV2UsersUserIDResponseMeta,  PatchScimV2UsersUserIDResponseName,  PatchScimV2UsersUserIDResponse400,  PatchScimV2UsersUserIDResponse401,  PatchScimV2UsersUserIDResponse403,  PatchScimV2UsersUserIDResponse404,  PatchScimV2UsersUserIDResponse429,  PatchScimV2UsersUserIDResponse500,  PostApisAPIIDCollectionsResponse,  PostApisAPIIDCollectionsResponse401,  PostApisAPIIDCollectionsResponse403,  PostApisAPIIDCollectionsResponse404,  PostApisAPIIDCollectionsResponse500,  PostApisAPIIDSchemasBody,  PostApisAPIIDSchemasBodyFilesItem,  PostApisAPIIDSchemasBodyFilesItemRoot,  PostApisAPIIDSchemasResponse,  PostApisAPIIDSchemasResponseFilesItem,  PostApisAPIIDSchemasResponse400,  PostApisAPIIDSchemasResponse401,  PostApisAPIIDSchemasResponse403,  PostApisAPIIDSchemasResponse404,  PostApisAPIIDSchemasResponse422,  PostApisAPIIDSchemasResponse500,  PostApisAPIIDVersionsResponse,  PostApisAPIIDVersionsResponse401,  PostApisAPIIDVersionsResponse403,  PostApisAPIIDVersionsResponse404,  PostApisAPIIDVersionsResponse422,  PostApisAPIIDVersionsResponse500,  PostApisBody,  PostApisResponse,  PostApisResponse400,  PostApisResponse401,  PostApisResponse403,  PostApisResponse404,  PostApisResponse500,  PostCollectionsBody,  PostCollectionsBodyCollection,  PostCollectionsBodyCollectionInfo,  PostCollectionsBodyCollectionItemItem,  PostCollectionsCollectionIDFoldersBody,  PostCollectionsCollectionIDFoldersResponse,  PostCollectionsCollectionIDFoldersResponseData,  PostCollectionsCollectionIDFoldersResponse400,  PostCollectionsCollectionIDFoldersResponse400Error,  PostCollectionsCollectionIDFoldersResponse400ErrorDetails,  PostCollectionsCollectionIDFoldersResponse401,  PostCollectionsCollectionIDFoldersResponse401Error,  PostCollectionsCollectionIDFoldersResponse401ErrorDetails,  PostCollectionsCollectionIDFoldersResponse500,  PostCollectionsCollectionIDRequestsBody,  PostCollectionsCollectionIDRequestsResponse,  PostCollectionsCollectionIDRequestsResponseData,  PostCollectionsCollectionIDRequestsResponse400,  PostCollectionsCollectionIDRequestsResponse400Error,  PostCollectionsCollectionIDRequestsResponse400ErrorDetails,  PostCollectionsCollectionIDRequestsResponse401,  PostCollectionsCollectionIDRequestsResponse401Error,  PostCollectionsCollectionIDRequestsResponse401ErrorDetails,  PostCollectionsCollectionIDRequestsResponse500,  PostCollectionsCollectionIDResponsesBody,  PostCollectionsCollectionIDResponsesResponse,  PostCollectionsCollectionIDResponsesResponseData,  PostCollectionsCollectionIDResponsesResponse400,  PostCollectionsCollectionIDResponsesResponse400Error,  PostCollectionsCollectionIDResponsesResponse400ErrorDetails,  PostCollectionsCollectionIDResponsesResponse401,  PostCollectionsCollectionIDResponsesResponse401Error,  PostCollectionsCollectionIDResponsesResponse401ErrorDetails,  PostCollectionsCollectionIDResponsesResponse500,  PostCollectionsForkCollectionIDBody,  PostCollectionsForkCollectionIDResponse,  PostCollectionsForkCollectionIDResponseCollection,  PostCollectionsForkCollectionIDResponseCollectionFork,  PostCollectionsForkCollectionIDResponse401,  PostCollectionsForkCollectionIDResponse401Error,  PostCollectionsForkCollectionIDResponse404,  PostCollectionsForkCollectionIDResponse404Error,  PostCollectionsForkCollectionIDResponse404ErrorDetails,  PostCollectionsForkCollectionIDResponse429,  PostCollectionsForkCollectionIDResponse500,  PostCollectionsForkCollectionIDResponse500Error,  PostCollectionsMergeBody,  PostCollectionsMergeResponse,  PostCollectionsMergeResponseCollection,  PostCollectionsMergeResponse401,  PostCollectionsMergeResponse401Error,  PostCollectionsMergeResponse404,  PostCollectionsMergeResponse404Error,  PostCollectionsMergeResponse404ErrorDetails,  PostCollectionsMergeResponse429,  PostCollectionsMergeResponse500,  PostCollectionsMergeResponse500Error,  PostCollectionsResponse,  PostCollectionsResponseCollection,  PostCollectionsResponse400,  PostCollectionsResponse400Error,  PostCollectionsResponse401,  PostCollectionsResponse401Error,  PostCollectionsResponse429,  PostCollectionsResponse500,  PostCollectionsResponse500Error,  PostDetectedSecretsQueriesBody,  PostDetectedSecretsQueriesResponse,  PostDetectedSecretsQueriesResponseDataItem,  PostDetectedSecretsQueriesResponseMeta,  PostDetectedSecretsQueriesResponse400,  PostDetectedSecretsQueriesResponse401,  PostDetectedSecretsQueriesResponse403,  PostDetectedSecretsQueriesResponse500,  PostEnvironmentsBody,  PostEnvironmentsBodyEnvironment,  PostEnvironmentsBodyEnvironmentValuesItemItem,  PostEnvironmentsResponse,  PostEnvironmentsResponseEnvironment,  PostEnvironmentsResponse400,  PostEnvironmentsResponse400Error,  PostEnvironmentsResponse401,  PostEnvironmentsResponse401Error,  PostEnvironmentsResponse403,  PostEnvironmentsResponse403Error,  PostEnvironmentsResponse429,  PostEnvironmentsResponse500,  PostEnvironmentsResponse500Error,  PostImportOpenapiResponse,  PostImportOpenapiResponseCollectionsItem,  PostImportOpenapiResponse400,  PostImportOpenapiResponse400Error,  PostImportOpenapiResponse400ErrorDetails,  PostImportOpenapiResponse401,  PostImportOpenapiResponse401Error,  PostImportOpenapiResponse429,  PostImportOpenapiResponse500,  PostImportOpenapiResponse500Error,  PostMocksBody,  PostMocksBodyMock,  PostMocksMockIDPublishResponse,  PostMocksMockIDPublishResponseMock,  PostMocksMockIDPublishResponse400,  PostMocksMockIDPublishResponse400Error,  PostMocksMockIDPublishResponse401,  PostMocksMockIDPublishResponse401Error,  PostMocksMockIDPublishResponse404,  PostMocksMockIDPublishResponse404Error,  PostMocksMockIDPublishResponse429,  PostMocksMockIDPublishResponse500,  PostMocksMockIDPublishResponse500Error,  PostMocksMockIDServerResponsesBody,  PostMocksMockIDServerResponsesBodyServerResponse,  PostMocksMockIDServerResponsesBodyServerResponseHeadersItem,  PostMocksMockIDServerResponsesResponse400,  PostMocksMockIDServerResponsesResponse400Error,  PostMocksMockIDServerResponsesResponse400ErrorDetails,  PostMocksMockIDServerResponsesResponse401,  PostMocksMockIDServerResponsesResponse401Error,  PostMocksMockIDServerResponsesResponse429,  PostMocksMockIDServerResponsesResponse500,  PostMocksMockIDServerResponsesResponse500Error,  PostMocksMockIDServerResponsesResponseItem,  PostMocksResponse,  PostMocksResponseMock,  PostMocksResponseMockConfig,  PostMocksResponseMockConfigDelay,  PostMocksResponse400,  PostMocksResponse400Error,  PostMocksResponse400ErrorDetails,  PostMocksResponse401,  PostMocksResponse401Error,  PostMocksResponse429,  PostMocksResponse500,  PostMocksResponse500Error,  PostMonitorsBody,  PostMonitorsBodyMonitor,  PostMonitorsBodyMonitorSchedule,  PostMonitorsMonitorIDRunResponse,  PostMonitorsMonitorIDRunResponseRun,  PostMonitorsMonitorIDRunResponseRunExecutionsItem,  PostMonitorsMonitorIDRunResponseRunExecutionsItemItem,  PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest,  PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse,  PostMonitorsMonitorIDRunResponseRunInfo,  PostMonitorsMonitorIDRunResponseRunStats,  PostMonitorsMonitorIDRunResponseRunStatsAssertions,  PostMonitorsMonitorIDRunResponseRunStatsRequests,  PostMonitorsMonitorIDRunResponse401,  PostMonitorsMonitorIDRunResponse401Error,  PostMonitorsMonitorIDRunResponse429,  PostMonitorsMonitorIDRunResponse500,  PostMonitorsMonitorIDRunResponse500Error,  PostMonitorsResponse,  PostMonitorsResponseMonitor,  PostMonitorsResponse400,  PostMonitorsResponse400Error,  PostMonitorsResponse401,  PostMonitorsResponse401Error,  PostMonitorsResponse403,  PostMonitorsResponse403Error,  PostMonitorsResponse429,  PostMonitorsResponse500,  PostMonitorsResponse500Error,  PostNetworkPrivateResponse401,  PostNetworkPrivateResponse401Error,  PostNetworkPrivateResponse403,  PostNetworkPrivateResponse403Error,  PostNetworkPrivateResponse404,  PostNetworkPrivateResponse404Error,  PostNetworkPrivateResponse429,  PostNetworkPrivateResponse500,  PostNetworkPrivateResponse500Error,  PostScimV2GroupsBody,  PostScimV2GroupsBodyName,  PostScimV2GroupsResponse,  PostScimV2GroupsResponseMeta,  PostScimV2GroupsResponseName,  PostScimV2GroupsResponse400,  PostScimV2GroupsResponse401,  PostScimV2GroupsResponse403,  PostScimV2GroupsResponse409,  PostScimV2GroupsResponse429,  PostScimV2GroupsResponse500,  PostScimV2UsersBody,  PostScimV2UsersBodyName,  PostScimV2UsersResponse,  PostScimV2UsersResponseMeta,  PostScimV2UsersResponseName,  PostScimV2UsersResponse400,  PostScimV2UsersResponse401,  PostScimV2UsersResponse403,  PostScimV2UsersResponse409,  PostScimV2UsersResponse429,  PostScimV2UsersResponse500,  PostSecurityAPIValidationBody,  PostSecurityAPIValidationBodySchema,  PostSecurityAPIValidationResponse,  PostSecurityAPIValidationResponse400,  PostSecurityAPIValidationResponse400Error,  PostSecurityAPIValidationResponse401,  PostSecurityAPIValidationResponse401Error,  PostSecurityAPIValidationResponse429,  PostSecurityAPIValidationResponse500,  PostSecurityAPIValidationResponse500Error,  PostWebhooksBody,  PostWebhooksBodyWebhook,  PostWebhooksResponse,  PostWebhooksResponseWebhook,  PostWebhooksResponse401,  PostWebhooksResponse401Error,  PostWebhooksResponse429,  PostWebhooksResponse500,  PostWebhooksResponse500Error,  PostWorkspacesBody,  PostWorkspacesBodyWorkspace,  PostWorkspacesResponse,  PostWorkspacesResponseWorkspace,  PostWorkspacesResponse400,  PostWorkspacesResponse401,  PostWorkspacesResponse401Error,  PostWorkspacesResponse404,  PostWorkspacesResponse404Error,  PostWorkspacesResponse429,  PostWorkspacesResponse500,  PostWorkspacesResponse500Error,  PutApisAPIIDBody,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404,  PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422,  PutApisAPIIDResponse,  PutApisAPIIDResponse401,  PutApisAPIIDResponse403,  PutApisAPIIDResponse404,  PutApisAPIIDResponse422,  PutApisAPIIDResponse500,  PutApisAPIIDSchemasSchemaIDFilesFilePathBody,  PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422,  PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500,  PutApisAPIIDTagsBody,  PutApisAPIIDTagsBodyTagsItem,  PutApisAPIIDTagsResponse,  PutApisAPIIDTagsResponseTagsItem,  PutApisAPIIDTagsResponse400,  PutApisAPIIDTagsResponse401,  PutApisAPIIDTagsResponse403,  PutApisAPIIDTagsResponse500,  PutApisAPIIDVersionsVersionIDBody,  PutApisAPIIDVersionsVersionIDResponse,  PutApisAPIIDVersionsVersionIDResponse401,  PutApisAPIIDVersionsVersionIDResponse403,  PutApisAPIIDVersionsVersionIDResponse404,  PutApisAPIIDVersionsVersionIDResponse500,  PutCollectionsCollectionIDBody,  PutCollectionsCollectionIDBodyCollection,  PutCollectionsCollectionIDBodyCollectionInfo,  PutCollectionsCollectionIDBodyCollectionItemItem,  PutCollectionsCollectionIDFoldersFolderIDBody,  PutCollectionsCollectionIDFoldersFolderIDResponse,  PutCollectionsCollectionIDFoldersFolderIDResponseData,  PutCollectionsCollectionIDFoldersFolderIDResponse400,  PutCollectionsCollectionIDFoldersFolderIDResponse400Error,  PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails,  PutCollectionsCollectionIDFoldersFolderIDResponse401,  PutCollectionsCollectionIDFoldersFolderIDResponse401Error,  PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails,  PutCollectionsCollectionIDFoldersFolderIDResponse404,  PutCollectionsCollectionIDFoldersFolderIDResponse404Error,  PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails,  PutCollectionsCollectionIDFoldersFolderIDResponse500,  PutCollectionsCollectionIDRequestsRequestIDBody,  PutCollectionsCollectionIDRequestsRequestIDResponse,  PutCollectionsCollectionIDRequestsRequestIDResponseData,  PutCollectionsCollectionIDRequestsRequestIDResponse400,  PutCollectionsCollectionIDRequestsRequestIDResponse400Error,  PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails,  PutCollectionsCollectionIDRequestsRequestIDResponse401,  PutCollectionsCollectionIDRequestsRequestIDResponse401Error,  PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails,  PutCollectionsCollectionIDRequestsRequestIDResponse404,  PutCollectionsCollectionIDRequestsRequestIDResponse404Error,  PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails,  PutCollectionsCollectionIDRequestsRequestIDResponse500,  PutCollectionsCollectionIDResponse,  PutCollectionsCollectionIDResponseCollection,  PutCollectionsCollectionIDResponse400,  PutCollectionsCollectionIDResponse400Error,  PutCollectionsCollectionIDResponse401,  PutCollectionsCollectionIDResponse401Error,  PutCollectionsCollectionIDResponse403,  PutCollectionsCollectionIDResponse403Error,  PutCollectionsCollectionIDResponse404,  PutCollectionsCollectionIDResponse404Error,  PutCollectionsCollectionIDResponse404ErrorDetails,  PutCollectionsCollectionIDResponse429,  PutCollectionsCollectionIDResponse500,  PutCollectionsCollectionIDResponse500Error,  PutCollectionsCollectionIDResponsesResponseIDBody,  PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode,  PutCollectionsCollectionIDResponsesResponseIDResponse,  PutCollectionsCollectionIDResponsesResponseIDResponseData,  PutCollectionsCollectionIDResponsesResponseIDResponse400,  PutCollectionsCollectionIDResponsesResponseIDResponse400Error,  PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails,  PutCollectionsCollectionIDResponsesResponseIDResponse401,  PutCollectionsCollectionIDResponsesResponseIDResponse401Error,  PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails,  PutCollectionsCollectionIDResponsesResponseIDResponse404,  PutCollectionsCollectionIDResponsesResponseIDResponse404Error,  PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails,  PutCollectionsCollectionIDResponsesResponseIDResponse500,  PutCollectionsCollectionIDTagsBody,  PutCollectionsCollectionIDTagsBodyTagsItem,  PutCollectionsCollectionIDTagsResponse,  PutCollectionsCollectionIDTagsResponseTagsItem,  PutCollectionsCollectionIDTagsResponse400,  PutCollectionsCollectionIDTagsResponse401,  PutCollectionsCollectionIDTagsResponse403,  PutCollectionsCollectionIDTagsResponse404,  PutCollectionsCollectionIDTagsResponse500,  PutDetectedSecretsSecretIDBody,  PutDetectedSecretsSecretIDResponse,  PutDetectedSecretsSecretIDResponseHistoryItem,  PutDetectedSecretsSecretIDResponse401,  PutDetectedSecretsSecretIDResponse403,  PutDetectedSecretsSecretIDResponse500,  PutEnvironmentsEnvironmentIDBody,  PutEnvironmentsEnvironmentIDBodyEnvironment,  PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem,  PutEnvironmentsEnvironmentIDResponse,  PutEnvironmentsEnvironmentIDResponseEnvironment,  PutEnvironmentsEnvironmentIDResponse400,  PutEnvironmentsEnvironmentIDResponse400Error,  PutEnvironmentsEnvironmentIDResponse401,  PutEnvironmentsEnvironmentIDResponse401Error,  PutEnvironmentsEnvironmentIDResponse429,  PutEnvironmentsEnvironmentIDResponse500,  PutEnvironmentsEnvironmentIDResponse500Error,  PutMocksMockIDBody,  PutMocksMockIDBodyMock,  PutMocksMockIDBodyMockConfig,  PutMocksMockIDResponse,  PutMocksMockIDResponseMock,  PutMocksMockIDResponseMockConfig,  PutMocksMockIDResponse401,  PutMocksMockIDResponse401Error,  PutMocksMockIDResponse404,  PutMocksMockIDResponse404Error,  PutMocksMockIDResponse429,  PutMocksMockIDResponse500,  PutMocksMockIDResponse500Error,  PutMocksMockIDServerResponsesServerResponseIDBody,  PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse,  PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem,  PutMocksMockIDServerResponsesServerResponseIDResponse400,  PutMocksMockIDServerResponsesServerResponseIDResponse400Error,  PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails,  PutMocksMockIDServerResponsesServerResponseIDResponse401,  PutMocksMockIDServerResponsesServerResponseIDResponse401Error,  PutMocksMockIDServerResponsesServerResponseIDResponse429,  PutMocksMockIDServerResponsesServerResponseIDResponse500,  PutMocksMockIDServerResponsesServerResponseIDResponse500Error,  PutMocksMockIDServerResponsesServerResponseIDResponseItem,  PutMonitorsMonitorIDBody,  PutMonitorsMonitorIDBodyMonitor,  PutMonitorsMonitorIDBodyMonitorSchedule,  PutMonitorsMonitorIDResponse,  PutMonitorsMonitorIDResponseMonitor,  PutMonitorsMonitorIDResponse401,  PutMonitorsMonitorIDResponse401Error,  PutMonitorsMonitorIDResponse404,  PutMonitorsMonitorIDResponse404Error,  PutMonitorsMonitorIDResponse429,  PutMonitorsMonitorIDResponse500,  PutMonitorsMonitorIDResponse500Error,  PutNetworkPrivateElementTypeElementIDResponse401,  PutNetworkPrivateElementTypeElementIDResponse401Error,  PutNetworkPrivateElementTypeElementIDResponse403,  PutNetworkPrivateElementTypeElementIDResponse403Error,  PutNetworkPrivateElementTypeElementIDResponse404,  PutNetworkPrivateElementTypeElementIDResponse404Error,  PutNetworkPrivateElementTypeElementIDResponse429,  PutNetworkPrivateElementTypeElementIDResponse500,  PutNetworkPrivateElementTypeElementIDResponse500Error,  PutNetworkPrivateNetworkEntityRequestRequestIDBody,  PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse,  PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem,  PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement,  PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse400,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse401,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse403,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse429,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse500,  PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error,  PutScimV2UsersUserIDBody,  PutScimV2UsersUserIDBodyName,  PutScimV2UsersUserIDResponse,  PutScimV2UsersUserIDResponseMeta,  PutScimV2UsersUserIDResponseName,  PutScimV2UsersUserIDResponse400,  PutScimV2UsersUserIDResponse401,  PutScimV2UsersUserIDResponse403,  PutScimV2UsersUserIDResponse404,  PutScimV2UsersUserIDResponse429,  PutScimV2UsersUserIDResponse500,  PutWorkspacesWorkspaceIDBody,  PutWorkspacesWorkspaceIDBodyWorkspace,  PutWorkspacesWorkspaceIDGlobalVariablesBody,  PutWorkspacesWorkspaceIDGlobalVariablesResponse,  PutWorkspacesWorkspaceIDGlobalVariablesResponse500,  PutWorkspacesWorkspaceIDResponse,  PutWorkspacesWorkspaceIDResponseWorkspace,  PutWorkspacesWorkspaceIDResponse400,  PutWorkspacesWorkspaceIDResponse403,  PutWorkspacesWorkspaceIDResponse403Error,  PutWorkspacesWorkspaceIDResponse404,  PutWorkspacesWorkspaceIDResponse404Error,  PutWorkspacesWorkspaceIDResponse429,  PutWorkspacesWorkspaceIDResponse500,  PutWorkspacesWorkspaceIDResponse500Error,  PutWorkspacesWorkspaceIDTagsBody,  PutWorkspacesWorkspaceIDTagsBodyTagsItem,  PutWorkspacesWorkspaceIDTagsResponse,  PutWorkspacesWorkspaceIDTagsResponseTagsItem,  PutWorkspacesWorkspaceIDTagsResponse400,  PutWorkspacesWorkspaceIDTagsResponse401,  PutWorkspacesWorkspaceIDTagsResponse403,  PutWorkspacesWorkspaceIDTagsResponse404,  PutWorkspacesWorkspaceIDTagsResponse500,  APIBase,  APIDetails,  APIDetailsCollectionsItem,  APIDetailsGitInfo,  APIDetailsSchemasItem,  APIDetailsVersionsItem,  CreateAPIVersionGitLinked,  CreateAPIVersionGitLinkedCollectionsItem,  CreateAPIVersionGitLinkedSchemasItem,  CreateAPIVersionNonGitLinked,  CreateAPIVersionNonGitLinkedCollectionsItem,  CreateAPIVersionNonGitLinkedSchemasItem,  CreateAPISchema,  CreateAPISchemaFilesItem,  CreateAPISchemaFilesItemRoot,  CreatePANAPI,  CreatePanAPIAPI,  CreatePANCollection,  CreatePanCollectionCollection,  CreatePANFolder,  CreatePanFolderFolder,  CreatePANWorkspace,  CreatePanWorkspaceWorkspace,  CreateUpdateAPI,  GitInfo,  ImportExportFile,  JSONSchema,  JSONStringified,  Meta,  SchemaFileBase,  SchemaFileContents,  TaskError,  TaskErrorError,  TaskResource,  TaskResourceResourcesItem,  UpdatePANAPI,  UpdatePanAPIAPI,  UpdatePANCollection,  UpdatePanCollectionCollection,  UpdatePanCollectionCollectionEnvironments,  UpdatePANFolder,  UpdatePanFolderFolder,  UpdatePANWorkspace,  UpdatePanWorkspaceWorkspace,  VersionBase,  VersionExtended,  VersionExtendedCollectionsItem,  VersionExtendedSchemasItem,  }  from "./schemas";

type NestedArray<T> = T | NestedArray<T>[];

export default class SidekoClient {

    public instance: AxiosInstance; 
    constructor(apiKey: string,  baseURL?: string) {
        const base = baseURL || "https://api.getpostman.com";
        this.instance = axios.create({
            baseURL: base,
            timeout: 1000,
            headers: { "x-api-key": apiKey },
        })
    }

    private toJsonEncodable<T>(target: T | NestedArray<T>, converter: (obj: T) => string): any {
        if (Array.isArray(target)) {
            return target.map(el => this.toJsonEncodable(el, converter))
        }
        return JSON.parse(converter(target))
    }

    private fromJsonEncodable<T>(target: any, converter: (jsonStr: string) => T): any {
        if (Array.isArray(target)) {
            return target.map(el => this.fromJsonEncodable(el, converter))
        }
        return converter(JSON.stringify(target))
    }

    public async deleteApi(request: { apiId: string }): Promise<any> {
        // Deletes an API.
        const axiosConfig = {
            method: "DELETE",
            url: `/apis/${request.apiId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async deleteSchemaFile(request: { apiId: string, schemaId: string, filePath: string }): Promise<any> {
        // Deletes a file in an API schema.
        const axiosConfig = {
            method: "DELETE",
            url: `/apis/${request.apiId}/schemas/${request.schemaId}/files/${request.filePath}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async deleteApiVersion(request: { apiId: string, versionId: string }): Promise<any> {
        // Deletes an API version. -  - **Note:** -  - This endpoint returns an HTTP &#x60;404 Not Found&#x60; response when an API version is pending publication. - 
        const axiosConfig = {
            method: "DELETE",
            url: `/apis/${request.apiId}/versions/${request.versionId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async deleteCollection(request: { collectionId: string }): Promise<DeleteCollectionsCollectionIDResponse> {
        // Deletes a collection.
        const axiosConfig = {
            method: "DELETE",
            url: `/collections/${request.collectionId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteCollectionsCollectionIDResponse);

        return responseData;
    }

    public async deleteCollectionFolder(request: { collectionId: string, folderId: string }): Promise<DeleteCollectionsCollectionIDFoldersFolderIDResponse> {
        // Deletes a folder in a collection.
        const axiosConfig = {
            method: "DELETE",
            url: `/collections/${request.collectionId}/folders/${request.folderId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteCollectionsCollectionIDFoldersFolderIDResponse);

        return responseData;
    }

    public async deleteCollectionRequest(request: { collectionId: string, requestId: string }): Promise<DeleteCollectionsCollectionIDRequestsRequestIDResponse> {
        // Deletes a request in a collection.
        const axiosConfig = {
            method: "DELETE",
            url: `/collections/${request.collectionId}/requests/${request.requestId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteCollectionsCollectionIDRequestsRequestIDResponse);

        return responseData;
    }

    public async deleteCollectionResponse(request: { collectionId: string, responseId: string }): Promise<DeleteCollectionsCollectionIDResponsesResponseIDResponse> {
        // Deletes a response in a collection.
        const axiosConfig = {
            method: "DELETE",
            url: `/collections/${request.collectionId}/responses/${request.responseId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteCollectionsCollectionIDResponsesResponseIDResponse);

        return responseData;
    }

    public async deleteEnvironment(request: { environmentId: string }): Promise<DeleteEnvironmentsEnvironmentIDResponse> {
        // Deletes an environment.
        const axiosConfig = {
            method: "DELETE",
            url: `/environments/${request.environmentId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteEnvironmentsEnvironmentIDResponse);

        return responseData;
    }

    public async deleteMock(request: { mockId: string }): Promise<DeleteMocksMockIDResponse> {
        // Deletes a mock server.
        const axiosConfig = {
            method: "DELETE",
            url: `/mocks/${request.mockId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteMocksMockIDResponse);

        return responseData;
    }

    public async deleteMockServerResponse(request: { mockId: string, serverResponseId: string }): Promise<DeleteMocksMockIDServerResponsesServerResponseIDResponse> {
        // Deletes a mock server&#x27;s server response.
        const axiosConfig = {
            method: "DELETE",
            url: `/mocks/${request.mockId}/server-responses/${request.serverResponseId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteMocksMockIDServerResponsesServerResponseIDResponse);

        return responseData;
    }

    public async unpublishMock(request: { mockId: string }): Promise<DeleteMocksMockIDUnpublishResponse> {
        // Unpublishes a mock server. Unpublishing a mock server sets its **Access Control** configuration setting to private.
        const axiosConfig = {
            method: "DELETE",
            url: `/mocks/${request.mockId}/unpublish`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteMocksMockIDUnpublishResponse);

        return responseData;
    }

    public async deleteMonitor(request: { monitorId: string }): Promise<DeleteMonitorsMonitorIDResponse> {
        // Deletes a monitor.
        const axiosConfig = {
            method: "DELETE",
            url: `/monitors/${request.monitorId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteMonitorsMonitorIDResponse);

        return responseData;
    }

    public async removeElementOrFolder(request: { elementType: string, elementId: string }): Promise<DeleteNetworkPrivateElementTypeElementIDResponse> {
        // Removes an element or delete a folder from your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). -  - **Note:** -  - Removing an API, collection, or workspace element does **not** delete it. It only removes it from the Private API Network folder.
        const axiosConfig = {
            method: "DELETE",
            url: `/network/private/${request.elementType}/${request.elementId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteNetworkPrivateElementTypeElementIDResponse);

        return responseData;
    }

    public async deleteGroup(request: { groupId: string }): Promise<any> {
        // Deletes a group in Postman. -  - User accounts that were in the deleted group are deactivated in Postman if the app is assigned to the user only with the deleted group. -  - User accounts and the data corresponding to them are **not** deleted. To permanently delete user accounts and their data, [contact Postman support](https://www.postman.com/support/). - 
        const axiosConfig = {
            method: "DELETE",
            url: `/scim/v2/Groups/${request.groupId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async deleteWorkspace(request: { workspaceId: string }): Promise<DeleteWorkspacesWorkspaceIDResponse> {
        // Deletes an existing workspace. -  - ### Important -  - If you delete a workspace that has a linked collection or environment with another workspace, this will delete the collection and environment in **all** workspaces. - 
        const axiosConfig = {
            method: "DELETE",
            url: `/workspaces/${request.workspaceId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toDeleteWorkspacesWorkspaceIDResponse);

        return responseData;
    }

    public async getAllApis(request: { workspaceId: string, createdBy?: number, cursor?: string, description?: string, limit?: number }): Promise<GetApisResponse> {
        // Gets information about all APIs in a workspace. -  - **Note:** -  - This endpoint only returns APIs created or migrated in Postman v10 and higher. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;
        axiosConfig.params["created_by"] = request.createdBy;
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["description"] = request.description;
        axiosConfig.params["limit"] = request.limit;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisResponse);

        return responseData;
    }

    public async getAnApi(request: { apiId: string, include?: string[] }): Promise<any> {
        // Gets information about an API. -  - **Note:** -  - - Git-connected APIs will **only** return the &#x60;versions&#x60; and &#x60;gitInfo&#x60; query responses. This is because schema and collection information is stored in the connected Git repository. The &#x60;gitInfo&#x60; object only lists the repository and folder locations of the files. - - API viewers can only use the &#x60;versions&#x60; option in the &#x60;include&#x60; query parameter. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["include"] = request.include;

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async getCollection(request: { apiId: string, collectionId: string, versionId?: string }): Promise<GetApisAPIIDCollectionsCollectionIDResponse> {
        // Gets a collection attached to an API. You can use the &#x60;versionId&#x60; query parameter to get a collection published in a version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/collections/${request.collectionId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["version_id"] = request.versionId;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDCollectionsCollectionIDResponse);

        return responseData;
    }

    public async getSchema(request: { apiId: string, schemaId: string, bundled?: boolean, versionId?: string }): Promise<any> {
        // Gets information about API schema. You can use the &#x60;versionId&#x60; query parameter to get a schema published in an API version. -  - You can use this API to do the following: -  - - Get a schema&#x27;s metadata. - - Get all the files in a schema. This only returns the first file in the schema. The endpoint response contains a link to the next set of response results. - - Get a schema&#x27;s contents in multi-file or bundled format. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a **required** parameter for API viewers. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/schemas/${request.schemaId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["bundled"] = request.bundled;
        axiosConfig.params["version_id"] = request.versionId;

        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async getSchemaFiles(request: { apiId: string, schemaId: string, cursor?: string, limit?: number, versionId?: string }): Promise<GetApisAPIIDSchemasSchemaIDFilesResponse> {
        // Gets the files in an API schema. You can use the &#x60;versionId&#x60; query parameter to get schema files published in an API version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/schemas/${request.schemaId}/files`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["limit"] = request.limit;
        axiosConfig.params["version_id"] = request.versionId;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDSchemasSchemaIDFilesResponse);

        return responseData;
    }

    public async getSchemaFileContents(request: { apiId: string, schemaId: string, filePath: string, versionId?: string }): Promise<GetApisAPIIDSchemasSchemaIDFilesFilePathResponse> {
        // Gets an API schema file contents at the defined path. You can use the &#x60;versionId&#x60; query parameter to get schema file contents published in an API version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/schemas/${request.schemaId}/files/${request.filePath}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["version_id"] = request.versionId;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDSchemasSchemaIDFilesFilePathResponse);

        return responseData;
    }

    public async getApiTags(request: { apiId: string }): Promise<GetApisAPIIDTagsResponse> {
        // Gets all the tags associated with an API.
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/tags`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDTagsResponse);

        return responseData;
    }

    public async getStatusOfAnAsyncTask(request: { apiId: string, taskId: string }): Promise<GetApisAPIIDTasksTaskIDResponse> {
        // Gets the status of an asynchronous task.
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/tasks/${request.taskId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDTasksTaskIDResponse);

        return responseData;
    }

    public async getAllVersions(request: { apiId: string, cursor?: string, limit?: number }): Promise<GetApisAPIIDVersionsResponse> {
        // Gets all the published versions of an API.
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/versions`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["limit"] = request.limit;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDVersionsResponse);

        return responseData;
    }

    public async getApiVersion(request: { apiId: string, versionId: string }): Promise<GetApisAPIIDVersionsVersionIDResponse> {
        // Gets information about an API version. -  - **Note:** -  - - For API editors, this endpoint returns an HTTP &#x60;302 Found&#x60; status code when the version status is pending. It also returns the &#x60;/apis/{apiId}/tasks/{taskId}&#x60; task status response header. - - For API viewers, this endpoint returns an HTTP &#x60;404 Not Found&#x60; when the version status is pending. - 
        const axiosConfig = {
            method: "GET",
            url: `/apis/${request.apiId}/versions/${request.versionId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetApisAPIIDVersionsVersionIDResponse);

        return responseData;
    }

    public async getAuditLogs(request: { cursor?: string, limit?: number, orderBy?: string, since?: string, until?: string }): Promise<GetAuditLogsResponse> {
        // Gets a list of your team&#x27;s generated audit events. For a complete list of all audit events, read our [Utilizing audit logs](https://learning.postman.com/docs/administration/audit-logs/) documentation.
        const axiosConfig = {
            method: "GET",
            url: `/audit/logs`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["limit"] = request.limit;
        axiosConfig.params["order_by"] = request.orderBy;
        axiosConfig.params["since"] = request.since;
        axiosConfig.params["until"] = request.until;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetAuditLogsResponse);

        return responseData;
    }

    public async allCollections(request: { name?: string, workspaceId?: string }): Promise<GetCollectionsResponse> {
        // Gets all of your [collections](https://www.getpostman.com/docs/collections). The response includes all of your subscribed collections.
        const axiosConfig = {
            method: "GET",
            url: `/collections`,
            params: {},
            headers: {},
        };
        axiosConfig.params["name"] = request.name;
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsResponse);

        return responseData;
    }

    public async singleCollection(request: { collectionId: string, accessKey?: string }): Promise<GetCollectionsCollectionIDResponse> {
        // Gets information about a collection. For a complete list of this endpoint&#x27;s possible values, use the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["access_key"] = request.accessKey;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDResponse);

        return responseData;
    }

    public async getCollectionFolder(request: { collectionId: string, folderId: string, ids?: boolean, populate?: boolean, uid?: boolean }): Promise<GetCollectionsCollectionIDFoldersFolderIDResponse> {
        // Gets information about a folder in a collection.
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}/folders/${request.folderId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["ids"] = request.ids;
        axiosConfig.params["populate"] = request.populate;
        axiosConfig.params["uid"] = request.uid;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDFoldersFolderIDResponse);

        return responseData;
    }

    public async getCollectionRequest(request: { collectionId: string, requestId: string, ids?: string, populate?: boolean, uid?: boolean }): Promise<GetCollectionsCollectionIDRequestsRequestIDResponse> {
        // Gets information about a request in a collection.
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}/requests/${request.requestId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["ids"] = request.ids;
        axiosConfig.params["populate"] = request.populate;
        axiosConfig.params["uid"] = request.uid;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDRequestsRequestIDResponse);

        return responseData;
    }

    public async getCollectionResponse(request: { collectionId: string, responseId: string, ids?: boolean, populate?: boolean, uid?: boolean }): Promise<GetCollectionsCollectionIDResponsesResponseIDResponse> {
        // Gets information about a response in a collection.
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}/responses/${request.responseId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["ids"] = request.ids;
        axiosConfig.params["populate"] = request.populate;
        axiosConfig.params["uid"] = request.uid;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDResponsesResponseIDResponse);

        return responseData;
    }

    public async getCollectionTags(request: { collectionId: string }): Promise<GetCollectionsCollectionIDTagsResponse> {
        // Gets all the tags associated with a collection.
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}/tags`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDTagsResponse);

        return responseData;
    }

    public async transformCollectionToOpenApi(request: { collectionId: string }): Promise<GetCollectionsCollectionIDTransformationsResponse> {
        // Transforms an existing Postman Collection into a stringified OpenAPI definition. -  - **Note:** -  - This does **not** create an API. - 
        const axiosConfig = {
            method: "GET",
            url: `/collections/${request.collectionId}/transformations`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetCollectionsCollectionIDTransformationsResponse);

        return responseData;
    }

    public async getDetectedSecretsLocations(request: { secretId: string, workspaceId: string, cursor?: string, limit?: number }): Promise<GetDetectedSecretsSecretIDLocationsResponse> {
        // Gets the locations of secrets detected by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/).
        const axiosConfig = {
            method: "GET",
            url: `/detected-secrets/${request.secretId}/locations`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["limit"] = request.limit;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetDetectedSecretsSecretIDLocationsResponse);

        return responseData;
    }

    public async allEnvironments(request: { workspaceId?: string }): Promise<GetEnvironmentsResponse> {
        // Gets information about all of your [environments](https://learning.postman.com/docs/sending-requests/managing-environments/).
        const axiosConfig = {
            method: "GET",
            url: `/environments`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetEnvironmentsResponse);

        return responseData;
    }

    public async singleEnvironment(request: { environmentId: string }): Promise<GetEnvironmentsEnvironmentIDResponse> {
        // Gets information about an environment.
        const axiosConfig = {
            method: "GET",
            url: `/environments/${request.environmentId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetEnvironmentsEnvironmentIDResponse);

        return responseData;
    }

    public async apiKeyOwner(): Promise<GetMeResponse> {
        // Gets information about the authenticated user. -  - **Note:** -  - This API returns a different response for users with the [Guest role](https://learning.postman.com/docs/collaborating-in-postman/roles-and-permissions/#team-roles). - 
        const axiosConfig = {
            method: "GET",
            url: `/me`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMeResponse);

        return responseData;
    }

    public async getMocks(request: { teamId?: string, workspace?: string }): Promise<GetMocksResponse> {
        // Gets all mock servers. By default, this endpoint returns only mock servers you created across all workspaces. -  - **Note:** -  - If you pass both the &#x60;teamId&#x60; and &#x60;workspace&#x60; query parameters, this endpoint only accepts the &#x60;workspace&#x60; query. - 
        const axiosConfig = {
            method: "GET",
            url: `/mocks`,
            params: {},
            headers: {},
        };
        axiosConfig.params["team_id"] = request.teamId;
        axiosConfig.params["workspace"] = request.workspace;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMocksResponse);

        return responseData;
    }

    public async getMock(request: { mockId: string }): Promise<GetMocksMockIDResponse> {
        // Gets information about a mock server.
        const axiosConfig = {
            method: "GET",
            url: `/mocks/${request.mockId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMocksMockIDResponse);

        return responseData;
    }

    public async getMockCallLogs(request: { mockId: string, cursor?: string, direction?: string, include?: string, limit?: number, requestMethod?: string, requestPath?: string, responseStatusCode?: number, responseType?: string, since?: string, sort?: string, until?: string }): Promise<GetMocksMockIDCallLogsResponse> {
        // Gets a mock server&#x27;s call logs. You can get a maximum of 6.5MB of call logs or a total of 100 call logs, whichever limit is met first in one API call. -  - Call logs contain exchanged request and response data made to mock servers. The logs provide visibility into how the mock servers are being used. You can log data to debug, test, analyze, and more, depending upon the use case. - 
        const axiosConfig = {
            method: "GET",
            url: `/mocks/${request.mockId}/call-logs`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["direction"] = request.direction;
        axiosConfig.params["include"] = request.include;
        axiosConfig.params["limit"] = request.limit;
        axiosConfig.params["request_method"] = request.requestMethod;
        axiosConfig.params["request_path"] = request.requestPath;
        axiosConfig.params["response_status_code"] = request.responseStatusCode;
        axiosConfig.params["response_type"] = request.responseType;
        axiosConfig.params["since"] = request.since;
        axiosConfig.params["sort"] = request.sort;
        axiosConfig.params["until"] = request.until;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMocksMockIDCallLogsResponse);

        return responseData;
    }

    public async getMockServerResponses(request: { mockId: string }): Promise<GetMocksMockIDServerResponsesResponseItem[]> {
        // Gets all of a mock server&#x27;s server responses.
        const axiosConfig = {
            method: "GET",
            url: `/mocks/${request.mockId}/server-responses`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMocksMockIDServerResponsesResponseItem);

        return responseData;
    }

    public async getMockServerResponse(request: { mockId: string, serverResponseId: string }): Promise<GetMocksMockIDServerResponsesServerResponseIDResponseItem[]> {
        // Gets information about a server response.
        const axiosConfig = {
            method: "GET",
            url: `/mocks/${request.mockId}/server-responses/${request.serverResponseId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMocksMockIDServerResponsesServerResponseIDResponseItem);

        return responseData;
    }

    public async allMonitors(request: { workspace?: string }): Promise<GetMonitorsResponse> {
        // Gets all monitors.
        const axiosConfig = {
            method: "GET",
            url: `/monitors`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace"] = request.workspace;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMonitorsResponse);

        return responseData;
    }

    public async singleMonitor(request: { monitorId: string }): Promise<GetMonitorsMonitorIDResponse> {
        // Gets information about a monitor.
        const axiosConfig = {
            method: "GET",
            url: `/monitors/${request.monitorId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetMonitorsMonitorIDResponse);

        return responseData;
    }

    public async getAllElementsAndFolders(request: { addedBy?: number, createdBy?: number, description?: string, direction?: string, limit?: number, name?: string, offset?: number, parentFolderId?: number, since?: string, sort?: string, summary?: string, type?: string, until?: string }): Promise<GetNetworkPrivateResponse> {
        // Gets information about the folders and their elements added to your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). -  - **Note:** -  - The &#x60;limit&#x60; and &#x60;offset&#x60; parameters are separately applied to elements and folders. For example, if you query a &#x60;limit&#x60; value of &#x60;10&#x60; and an &#x60;offset&#x60; value &#x60;0&#x60;, the endpoint returns 10 elements and 10 folders for a total of 20 items. The &#x60;totalCount&#x60; property in the &#x60;meta&#x60; response is the total count of **both** elements and folders.
        const axiosConfig = {
            method: "GET",
            url: `/network/private`,
            params: {},
            headers: {},
        };
        axiosConfig.params["added_by"] = request.addedBy;
        axiosConfig.params["created_by"] = request.createdBy;
        axiosConfig.params["description"] = request.description;
        axiosConfig.params["direction"] = request.direction;
        axiosConfig.params["limit"] = request.limit;
        axiosConfig.params["name"] = request.name;
        axiosConfig.params["offset"] = request.offset;
        axiosConfig.params["parent_folder_id"] = request.parentFolderId;
        axiosConfig.params["since"] = request.since;
        axiosConfig.params["sort"] = request.sort;
        axiosConfig.params["summary"] = request.summary;
        axiosConfig.params["type"] = request.type;
        axiosConfig.params["until"] = request.until;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetNetworkPrivateResponse);

        return responseData;
    }

    public async getAllAddElementRequests(request: { direction?: string, limit?: number, name?: string, offset?: number, requestedBy?: number, since?: string, sort?: string, status?: string, type?: string, until?: string }): Promise<GetNetworkPrivateNetworkEntityRequestAllResponse> {
        // Gets a list requests to add elements to the [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/).
        const axiosConfig = {
            method: "GET",
            url: `/network/private/network-entity/request/all`,
            params: {},
            headers: {},
        };
        axiosConfig.params["direction"] = request.direction;
        axiosConfig.params["limit"] = request.limit;
        axiosConfig.params["name"] = request.name;
        axiosConfig.params["offset"] = request.offset;
        axiosConfig.params["requested_by"] = request.requestedBy;
        axiosConfig.params["since"] = request.since;
        axiosConfig.params["sort"] = request.sort;
        axiosConfig.params["status"] = request.status;
        axiosConfig.params["type"] = request.type;
        axiosConfig.params["until"] = request.until;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetNetworkPrivateNetworkEntityRequestAllResponse);

        return responseData;
    }

    public async fetchAllGroupResources(request: { count?: number, filter?: string, startIndex?: number }): Promise<GetScimV2GroupsResponse> {
        // Gets information about all Postman team members.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/Groups`,
            params: {},
            headers: {},
        };
        axiosConfig.params["count"] = request.count;
        axiosConfig.params["filter"] = request.filter;
        axiosConfig.params["start_index"] = request.startIndex;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2GroupsResponse);

        return responseData;
    }

    public async fetchGroupResource(request: { groupId: string }): Promise<GetScimV2GroupsGroupIDResponse> {
        // Gets information about a Postman group within the team.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/Groups/${request.groupId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2GroupsGroupIDResponse);

        return responseData;
    }

    public async getResourceTypes(): Promise<GetScimV2ResourceTypesResponseItem[]> {
        // Gets all the resource types supported by Postman&#x27;s SCIM API.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/ResourceTypes`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2ResourceTypesResponseItem);

        return responseData;
    }

    public async serviceProviderConfig(): Promise<GetScimV2ServiceProviderConfigResponse> {
        // Gets the Postman SCIM API configuration information. This includes a list of supported operations.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/ServiceProviderConfig`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2ServiceProviderConfigResponse);

        return responseData;
    }

    public async fetchAllUserResources(request: { count?: number, filter?: string, startIndex?: number }): Promise<GetScimV2UsersResponse> {
        // Gets information about all Postman team members.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/Users`,
            params: {},
            headers: {},
        };
        axiosConfig.params["count"] = request.count;
        axiosConfig.params["filter"] = request.filter;
        axiosConfig.params["start_index"] = request.startIndex;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2UsersResponse);

        return responseData;
    }

    public async fetchUserResource(request: { userId: string }): Promise<GetScimV2UsersUserIDResponse> {
        // Gets information about a Postman team member.
        const axiosConfig = {
            method: "GET",
            url: `/scim/v2/Users/${request.userId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetScimV2UsersUserIDResponse);

        return responseData;
    }

    public async getSecretTypes(): Promise<GetSecretTypesResponse> {
        // Gets the metadata of the secret types supported by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/). You can use a secret type&#x27;s ID in the response to query data with the POST &#x60;/detected-secrets/{secretId}&#x60; endpoint.
        const axiosConfig = {
            method: "GET",
            url: `/secret-types`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetSecretTypesResponse);

        return responseData;
    }

    public async getTaggedEntities(request: { slug: string, cursor?: string, direction?: string, entityType?: string, limit?: number }): Promise<GetTagsSlugEntitiesResponse> {
        // Gets Postman elements (entities) by a given tag. Tags enable you to organize and search [workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#tagging-a-workspace), [APIs](https://learning.postman.com/docs/designing-and-developing-your-api/managing-apis/#tagging-apis), and [collections](https://learning.postman.com/docs/collections/using-collections/#tagging-a-collection) that contain shared tags. -  - **Note:** -  - Tagging is available on [Postman Enterprise plans](https://www.postman.com/pricing/).
        const axiosConfig = {
            method: "GET",
            url: `/tags/${request.slug}/entities`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["direction"] = request.direction;
        axiosConfig.params["entity_type"] = request.entityType;
        axiosConfig.params["limit"] = request.limit;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetTagsSlugEntitiesResponse);

        return responseData;
    }

    public async allWorkspaces(request: { type?: string }): Promise<GetWorkspacesResponse> {
        // Gets all [workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/creating-workspaces/). The response includes your workspaces and any workspaces that you have access to. -  - **Note:** -  - This endpoint&#x27;s response contains the visibility field. Visibility determines who can access the workspace: -  - - &#x60;personal&#x60; — Only you can access the workspace. - - &#x60;team&#x60; — All team members can access the workspace. - - &#x60;private&#x60; — Only invited team members can access the workspace ([Professional and Enterprise plans only](https://www.postman.com/pricing)). - - &#x60;public&#x60; — Everyone can access the workspace. - - &#x60;partner&#x60; — Only invited team members and [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/) can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing) only). - 
        const axiosConfig = {
            method: "GET",
            url: `/workspaces`,
            params: {},
            headers: {},
        };
        axiosConfig.params["type"] = request.type;

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetWorkspacesResponse);

        return responseData;
    }

    public async singleWorkspace(request: { workspaceId: string }): Promise<GetWorkspacesWorkspaceIDResponse> {
        // Gets information about a workspace. -  - **Note:** -  - This endpoint&#x27;s response contains the &#x60;visibility&#x60; field. [Visibility](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility) determines who can access the workspace: -  - - &#x60;personal&#x60; — Only you can access the workspace. - - &#x60;team&#x60; — All team members can access the workspace. - - &#x60;private&#x60; — Only invited team members can access the workspace ([Professional and Enterprise plans only](https://www.postman.com/pricing)). - - &#x60;public&#x60; — Everyone can access the workspace. - - &#x60;partner&#x60; — Only invited team members and [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/) can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing) only). -  - ### Important -  - We have **deprecated** the &#x60;name&#x60; and &#x60;uid&#x60; responses in the following array of objects: -  - - &#x60;collections&#x60; - - &#x60;environments&#x60; - - &#x60;mocks&#x60; - - &#x60;monitors&#x60; - - &#x60;apis&#x60; - 
        const axiosConfig = {
            method: "GET",
            url: `/workspaces/${request.workspaceId}`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetWorkspacesWorkspaceIDResponse);

        return responseData;
    }

    public async getWorkspaceGlobalVariables(request: { workspaceId: string }): Promise<GetWorkspacesWorkspaceIDGlobalVariablesResponse> {
        // Gets a workspace&#x27;s global [variables](https://learning.postman.com/docs/sending-requests/variables/#variable-scopes).
        const axiosConfig = {
            method: "GET",
            url: `/workspaces/${request.workspaceId}/global-variables`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetWorkspacesWorkspaceIDGlobalVariablesResponse);

        return responseData;
    }

    public async getWorkspaceTags(request: { workspaceId: string }): Promise<GetWorkspacesWorkspaceIDTagsResponse> {
        // Gets all the tags associated with a workspace.
        const axiosConfig = {
            method: "GET",
            url: `/workspaces/${request.workspaceId}/tags`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toGetWorkspacesWorkspaceIDTagsResponse);

        return responseData;
    }

    public async patchCollection(request: { data: PatchCollectionsCollectionIDBody, collectionId: string }): Promise<PatchCollectionsCollectionIDResponse> {
        // Updates specific collection information, such as its name, events, or its variables. For more information about the &#x60;auth&#x60;, &#x60;variables&#x60;, and &#x60;events&#x60; properties, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): -  - - For &#x60;variables&#x60;, refer to &#x60;&quot;#/definitions/variable&quot;&#x60;. - - For &#x60;auth&#x60;, refer to &#x60;&quot;#/definitions/auth-attribute&quot;&#x60;. - - For &#x60;events&#x60;, refer to &#x60;&quot;#/definitions/event&quot;&#x60;. -  - For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). - 
        const axiosConfig = {
            method: "PATCH",
            url: `/collections/${request.collectionId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.patchCollectionsCollectionIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPatchCollectionsCollectionIDResponse);

        return responseData;
    }

    public async patchScimV2GroupsGroupId(request: { data: PatchScimV2GroupsGroupIDBody, groupId: string }): Promise<PatchScimV2GroupsGroupIDResponse> {
        // Updates a group&#x27;s information. Using this endpoint you can: -  - - Update a group&#x27;s name. - - Add or remove members from a Postman group. - 
        const axiosConfig = {
            method: "PATCH",
            url: `/scim/v2/Groups/${request.groupId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.patchScimV2GroupsGroupIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPatchScimV2GroupsGroupIDResponse);

        return responseData;
    }

    public async updateUserState(request: { data: PatchScimV2UsersUserIDBody, userId: string }): Promise<PatchScimV2UsersUserIDResponse> {
        // Updates a user&#x27;s active state in Postman. -  - ### Reactivating users -  - By setting the &#x60;active&#x60; property from &#x60;false&#x60; to &#x60;true&#x60;, this reactivates an account. This allows the account to authenticate in to Postman and adds the account back on to your Postman team. - 
        const axiosConfig = {
            method: "PATCH",
            url: `/scim/v2/Users/${request.userId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.patchScimV2UsersUserIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPatchScimV2UsersUserIDResponse);

        return responseData;
    }

    public async createApi(request: { data: PostApisBody, workspaceId: string }): Promise<PostApisResponse> {
        // Creates an API.
        const axiosConfig = {
            method: "POST",
            url: `/apis`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postApisBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostApisResponse);

        return responseData;
    }

    public async addCollection(request: { data: any, apiId: string }): Promise<PostApisAPIIDCollectionsResponse> {
        // Adds a collection to an API. To do this, use the following &#x60;operationType&#x60; values: -  - - &#x60;COPY_COLLECTION&#x60; — Copies a collection from the workspace and adds it to an API. - - &#x60;CREATE_NEW&#x60; — Creates a new collection by providing the new collection&#x27;s content. - - &#x60;GENERATE_FROM_SCHEMA&#x60; — Generates the collection from an API schema. -     - &#x60;options&#x60; — An object that contains advanced creation options and their values. You can find a complete list of properties and their values in Postman&#x27;s OpenAPI 3.0 to Postman Collection v2.1.0 Converter OPTIONS documentation. These properties are case-sensitive. - 
        const axiosConfig = {
            method: "POST",
            url: `/apis/${request.apiId}/collections`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = request.data;
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostApisAPIIDCollectionsResponse);

        return responseData;
    }

    public async createApiSchema(request: { data: PostApisAPIIDSchemasBody, apiId: string }): Promise<PostApisAPIIDSchemasResponse> {
        // Creates a schema for an API.
        const axiosConfig = {
            method: "POST",
            url: `/apis/${request.apiId}/schemas`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postApisAPIIDSchemasBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostApisAPIIDSchemasResponse);

        return responseData;
    }

    public async createApiVersion(request: { data: any, apiId: string }): Promise<PostApisAPIIDVersionsResponse> {
        // Creates a new API version asynchronously and immediately returns an HTTP &#x60;202 Accepted&#x60; response. The response contains a polling link to the task status API in the &#x60;Location&#x60; header. -  - This endpoint is equivalent to publishing a version in Postman app, which is the snapshot of API collections and schema at a given point in time. - 
        const axiosConfig = {
            method: "POST",
            url: `/apis/${request.apiId}/versions`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = request.data;
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostApisAPIIDVersionsResponse);

        return responseData;
    }

    public async createCollection(request: { data: PostCollectionsBody, workspaceId?: string }): Promise<PostCollectionsResponse> {
        // Creates a collection using the [Postman Collection v2 schema format](https://schema.postman.com/json/collection/v2.1.0/docs/index.html). -  - For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). -  - **Note:** -  - - For a complete list of available property values for this endpoint, use the following references available in the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): -     - &#x60;info&#x60; object — Use the &#x60;definitions.info&#x60; entry. -     - &#x60;item&#x60; object — Use the &#x60;definitions.items&#x60; entry. - - For all other possible values, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json). - 
        const axiosConfig = {
            method: "POST",
            url: `/collections`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsResponse);

        return responseData;
    }

    public async createAFork(request: { data: PostCollectionsForkCollectionIDBody, collectionId: string, workspace: string }): Promise<PostCollectionsForkCollectionIDResponse> {
        // Creates a [fork](https://learning.postman.com/docs/collaborating-in-postman/version-control/#creating-a-fork) from an existing collection into a workspace.
        const axiosConfig = {
            method: "POST",
            url: `/collections/fork/${request.collectionId}`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace"] = request.workspace;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsForkCollectionIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsForkCollectionIDResponse);

        return responseData;
    }

    public async mergeAFork(request: { data: PostCollectionsMergeBody }): Promise<PostCollectionsMergeResponse> {
        // Merges a forked collection back into its destination collection.
        const axiosConfig = {
            method: "POST",
            url: `/collections/merge`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsMergeBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsMergeResponse);

        return responseData;
    }

    public async createCollectionFolder(request: { data: PostCollectionsCollectionIDFoldersBody, collectionId: string }): Promise<PostCollectionsCollectionIDFoldersResponse> {
        // Creates a folder in a collection. For a complete list of properties, refer to &quot;Folder&quot; in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json). -  - You can use this endpoint to to import requests and responses into a newly-created folder. To do this, include the &#x60;requests&#x60; field and the list of request objects in the request body. For more information, see the provided example. -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a folder with a blank name. - 
        const axiosConfig = {
            method: "POST",
            url: `/collections/${request.collectionId}/folders`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsCollectionIDFoldersBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsCollectionIDFoldersResponse);

        return responseData;
    }

    public async createCollectionRequest(request: { data: PostCollectionsCollectionIDRequestsBody, collectionId: string, folderId?: string }): Promise<PostCollectionsCollectionIDRequestsResponse> {
        // Creates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/). -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a request with a blank name. - 
        const axiosConfig = {
            method: "POST",
            url: `/collections/${request.collectionId}/requests`,
            params: {},
            headers: {},
        };
        axiosConfig.params["folder_id"] = request.folderId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsCollectionIDRequestsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsCollectionIDRequestsResponse);

        return responseData;
    }

    public async createCollectionResponse(request: { data: PostCollectionsCollectionIDResponsesBody, collectionId: string, requestId: string }): Promise<PostCollectionsCollectionIDResponsesResponse> {
        // Creates a request response in a collection. For a complete list of properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram). -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a response with a blank name. - 
        const axiosConfig = {
            method: "POST",
            url: `/collections/${request.collectionId}/responses`,
            params: {},
            headers: {},
        };
        axiosConfig.params["request_id"] = request.requestId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postCollectionsCollectionIDResponsesBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostCollectionsCollectionIDResponsesResponse);

        return responseData;
    }

    public async detectedSecretsQueries(request: { data: PostDetectedSecretsQueriesBody, cursor?: string, include?: string, limit?: number }): Promise<PostDetectedSecretsQueriesResponse> {
        // Returns all secrets detected by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/), grouped by workspace. If you pass an empty request body, this endpoint returns all results.
        const axiosConfig = {
            method: "POST",
            url: `/detected-secrets-queries`,
            params: {},
            headers: {},
        };
        axiosConfig.params["cursor"] = request.cursor;
        axiosConfig.params["include"] = request.include;
        axiosConfig.params["limit"] = request.limit;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postDetectedSecretsQueriesBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostDetectedSecretsQueriesResponse);

        return responseData;
    }

    public async createEnvironment(request: { data: PostEnvironmentsBody, workspaceId?: string }): Promise<PostEnvironmentsResponse> {
        // Creates an environment.
        const axiosConfig = {
            method: "POST",
            url: `/environments`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postEnvironmentsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostEnvironmentsResponse);

        return responseData;
    }

    public async importExternalApiSpecification(request: { data: any, workspaceId?: string }): Promise<PostImportOpenapiResponse> {
        // Imports an OpenAPI definition into Postman as a new [Postman Collection](https://learning.postman.com/docs/getting-started/creating-the-first-collection/).
        const axiosConfig = {
            method: "POST",
            url: `/import/openapi`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = request.data;
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostImportOpenapiResponse);

        return responseData;
    }

    public async createMock(request: { data: PostMocksBody, workspaceId?: string }): Promise<PostMocksResponse> {
        // **In Postman v10 and higher you cannot create mocks for collections added to an API definition.** -  - Creates a mock server in a collection. - 
        const axiosConfig = {
            method: "POST",
            url: `/mocks`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postMocksBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostMocksResponse);

        return responseData;
    }

    public async publishMock(request: { mockId: string }): Promise<PostMocksMockIDPublishResponse> {
        // Publishes a mock server. Publishing a mock server sets its **Access Control** configuration setting to public.
        const axiosConfig = {
            method: "POST",
            url: `/mocks/${request.mockId}/publish`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostMocksMockIDPublishResponse);

        return responseData;
    }

    public async createServerResponse(request: { data: PostMocksMockIDServerResponsesBody, mockId: string }): Promise<PostMocksMockIDServerResponsesResponseItem[]> {
        // Creates a server response. Server responses let you simulate 5xx server-level responses, such as 500 or 503. -  - Server-level responses are agnostic to application-level logic. Server responses let you simulate this behavior on a mock server. You do not need to define each error for all exposed paths on the mock server. -  - If you set a server response as active, then all the calls to the mock server return with that active server response. -  - **Note:** -  - You can create multiple server responses for a mock server, but only one mock server can be set as active. - 
        const axiosConfig = {
            method: "POST",
            url: `/mocks/${request.mockId}/server-responses`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postMocksMockIDServerResponsesBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostMocksMockIDServerResponsesResponseItem);

        return responseData;
    }

    public async createMonitor(request: { data: PostMonitorsBody, workspaceId?: string }): Promise<PostMonitorsResponse> {
        // **In Postman v10 and higher you cannot create monitors for collections added to an API definition.** -  - Creates a monitor. - 
        const axiosConfig = {
            method: "POST",
            url: `/monitors`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postMonitorsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostMonitorsResponse);

        return responseData;
    }

    public async runAMonitor(request: { monitorId: string }): Promise<PostMonitorsMonitorIDRunResponse> {
        // Runs a monitor and returns its run results.
        const axiosConfig = {
            method: "POST",
            url: `/monitors/${request.monitorId}/run`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostMonitorsMonitorIDRunResponse);

        return responseData;
    }

    public async postElementOrFolder(request: { data: any }): Promise<any> {
        // Publishes a element or creates a folder in your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). An element is a Postman API, collection, or workspace.
        const axiosConfig = {
            method: "POST",
            url: `/network/private`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = request.data;
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async createGroup(request: { data: PostScimV2GroupsBody }): Promise<PostScimV2GroupsResponse> {
        // Creates a new user group in Postman and creates a new account for each group member. -  - Each account is added to your Postman team and authentication is activated for each user. If an existing Postman account uses an email that matches a group member&#x27;s email ID, an [email invite](https://postman.postman.co/docs/administration/managing-your-team/managing-your-team/#invites) to join your Postman team is sent to that user. Once the user accepts the invite, they&#x27;ll be added to your team. -  - By default, the system assigns new users the developer role. You can [update user roles in Postman](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#managing-team-roles). - 
        const axiosConfig = {
            method: "POST",
            url: `/scim/v2/Groups`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postScimV2GroupsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostScimV2GroupsResponse);

        return responseData;
    }

    public async createUser(request: { data: PostScimV2UsersBody }): Promise<PostScimV2UsersResponse> {
        // Creates a new user account in Postman and adds the user to your organization&#x27;s Postman team. If the account does not already exist, this also activates the user so they can authenticate in to your Postman team. -  - If the account already exists, the system sends the user an [email invite](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#inviting-users) to join the Postman team. The user joins the team once they accept the invite. -  - By default, the system assigns new users the developer role. You can [update user roles in Postman](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#managing-team-roles). - 
        const axiosConfig = {
            method: "POST",
            url: `/scim/v2/Users`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postScimV2UsersBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostScimV2UsersResponse);

        return responseData;
    }

    public async schemaSecurityValidation(request: { data: PostSecurityAPIValidationBody }): Promise<PostSecurityAPIValidationResponse> {
        // Performs an analysis on the given definition and returns any issues based on your [predefined rulesets](https://learning.postman.com/docs/api-governance/configurable-rules/configurable-rules-overview/). This endpoint can help you understand the violations&#x27; impact and offers solutions to help you resolve any errors. You can include this endpoint to your CI/CD process to automate schema validation. -  - For more information, see our [Rule violations in the API definition](https://learning.postman.com/docs/api-governance/api-definition/api-definition-warnings/) documentation. -  - **Note:** -  - - The maximum allowed size of the definition is 10 MB. - - You must [import and enable](https://learning.postman.com/docs/api-governance/configurable-rules/configuring-api-security-rules/) [Postman&#x27;s OWASP security rules](https://postman.postman.co/api-governance/libraries/postman_owasp/view) in Postman for this endpoint to return any security rule violations. - 
        const axiosConfig = {
            method: "POST",
            url: `/security/api-validation`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postSecurityAPIValidationBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostSecurityAPIValidationResponse);

        return responseData;
    }

    public async createWebhook(request: { data: PostWebhooksBody, workspaceId?: string }): Promise<PostWebhooksResponse> {
        // Creates a webhook that triggers a collection with a custom payload. You can get the webhook&#x27;s URL from the &#x60;webhookUrl&#x60; property in the endpoint&#x27;s response.
        const axiosConfig = {
            method: "POST",
            url: `/webhooks`,
            params: {},
            headers: {},
        };
        axiosConfig.params["workspace_id"] = request.workspaceId;

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postWebhooksBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostWebhooksResponse);

        return responseData;
    }

    public async createWorkspace(request: { data: PostWorkspacesBody }): Promise<PostWorkspacesResponse> {
        // Creates a new [workspace](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/creating-workspaces/). -  - ### Important -  - We **deprecated** linking collections or environments between workspaces. We do **not** recommend that you do this. -  - If you have a linked collection or environment, note the following: -  - - The endpoint does **not** create a clone of a collection or environment. - - Any changes you make to a linked collection or environment changes them in **all** workspaces. - - If you delete a collection or environment linked between workspaces, the system deletes it in **all** the workspaces. - 
        const axiosConfig = {
            method: "POST",
            url: `/workspaces`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.postWorkspacesBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPostWorkspacesResponse);

        return responseData;
    }

    public async updateAnApi(request: { data: PutApisAPIIDBody, apiId: string }): Promise<PutApisAPIIDResponse> {
        // Updates an API.
        const axiosConfig = {
            method: "PUT",
            url: `/apis/${request.apiId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putApisAPIIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutApisAPIIDResponse);

        return responseData;
    }

    public async syncCollectionWithSchema(request: { apiId: string, collectionId: string }): Promise<PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse> {
        // Syncs a collection attached to an API with the API schema. -  - This is an asynchronous endpoint that returns an HTTP &#x60;202 Accepted&#x60; response. The response contains a polling link to the &#x60;/apis/{apiId}/tasks/{taskId}&#x60; endpoint in the &#x60;Location&#x60; header. -  - **Note:** -  - This endpoint only supports the OpenAPI 3 schema type. - 
        const axiosConfig = {
            method: "PUT",
            url: `/apis/${request.apiId}/collections/${request.collectionId}/sync-with-schema-tasks`,
            params: {},
            headers: {},
        };

        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse);

        return responseData;
    }

    public async createOrUpdateSchemaFile(request: { data: PutApisAPIIDSchemasSchemaIDFilesFilePathBody, apiId: string, schemaId: string, filePath: string }): Promise<PutApisAPIIDSchemasSchemaIDFilesFilePathResponse> {
        // Creates or updates an API schema file. -  - **Note:** -  - - If the provided file path exists, the file will be updated with the new contents. - - If the provided file path does **not** exist, then a new schema file will be created. - - If the file path contains a &#x60;/&#x60; (forward slash) character, then a folder is created. For example, if the file path is the &#x60;dir/schema.json&#x60; value, then a &#x60;dir&#x60; folder is created with the &#x60;schema.json&#x60; file inside. - 
        const axiosConfig = {
            method: "PUT",
            url: `/apis/${request.apiId}/schemas/${request.schemaId}/files/${request.filePath}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putApisAPIIDSchemasSchemaIDFilesFilePathBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutApisAPIIDSchemasSchemaIDFilesFilePathResponse);

        return responseData;
    }

    public async updateApiTags(request: { data: PutApisAPIIDTagsBody, apiId: string }): Promise<PutApisAPIIDTagsResponse> {
        // Updates an API&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body.
        const axiosConfig = {
            method: "PUT",
            url: `/apis/${request.apiId}/tags`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putApisAPIIDTagsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutApisAPIIDTagsResponse);

        return responseData;
    }

    public async updateApiVersion(request: { data: PutApisAPIIDVersionsVersionIDBody, apiId: string, versionId: string }): Promise<PutApisAPIIDVersionsVersionIDResponse> {
        // Updates an API version. -  - **Note:** -  - This endpoint returns an HTTP &#x60;404 Not Found&#x60; response when an API version is pending publication. - 
        const axiosConfig = {
            method: "PUT",
            url: `/apis/${request.apiId}/versions/${request.versionId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putApisAPIIDVersionsVersionIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutApisAPIIDVersionsVersionIDResponse);

        return responseData;
    }

    public async putCollection(request: { data: PutCollectionsCollectionIDBody, collectionId: string }): Promise<PutCollectionsCollectionIDResponse> {
        // Replaces the contents of a collection using the [Postman Collection v2 schema format](https://schema.postman.com/json/collection/v2.1.0/docs/index.html). Include the collection&#x27;s ID values in the request body. If you do not, the endpoint removes the existing items and creates new items. -  - For a complete list of available property values for this endpoint, use the following references available in the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): - - &#x60;info&#x60; object — Use &#x60;&quot;#/definitions/info&quot;&#x60;. - - &#x60;item&#x60; object — Use &#x60;&quot;#/definitions/item&quot;&#x60;. -  - For all other possible values, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json). For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). -  - **Note** -  - To copy another collection&#x27;s contents to the given collection, **remove** all ID values before you pass it in this endpoint. If you do not, this endpoint returns an error. These values include the &#x60;id&#x60;, &#x60;uid&#x60;, and &#x60;postman_id&#x60; values. - 
        const axiosConfig = {
            method: "PUT",
            url: `/collections/${request.collectionId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putCollectionsCollectionIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutCollectionsCollectionIDResponse);

        return responseData;
    }

    public async updateCollectionFolder(request: { data: PutCollectionsCollectionIDFoldersFolderIDBody, collectionId: string, folderId: string }): Promise<PutCollectionsCollectionIDFoldersFolderIDResponse> {
        // Updates a folder in a collection. For a complete list of properties, refer to &quot;Folder&quot; in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json). -  - **Note:** -  - This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the &#x60;name&#x60; property). The endpoint does **not** update the entire resource. - 
        const axiosConfig = {
            method: "PUT",
            url: `/collections/${request.collectionId}/folders/${request.folderId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putCollectionsCollectionIDFoldersFolderIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutCollectionsCollectionIDFoldersFolderIDResponse);

        return responseData;
    }

    public async updateCollectionRequest(request: { data: PutCollectionsCollectionIDRequestsRequestIDBody, collectionId: string, requestId: string }): Promise<PutCollectionsCollectionIDRequestsRequestIDResponse> {
        // Updates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/). -  - **Note:** -  - - You must pass a collection ID (&#x60;12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), not a collection(&#x60;12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), in this endpoint. - - This endpoint does not support changing the folder of a request. - 
        const axiosConfig = {
            method: "PUT",
            url: `/collections/${request.collectionId}/requests/${request.requestId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putCollectionsCollectionIDRequestsRequestIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutCollectionsCollectionIDRequestsRequestIDResponse);

        return responseData;
    }

    public async updateCollectionResponse(request: { data: PutCollectionsCollectionIDResponsesResponseIDBody, collectionId: string, responseId: string }): Promise<PutCollectionsCollectionIDResponsesResponseIDResponse> {
        // Updates a response in a collection. For a complete list of properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram). -  - **Note:** -  - - You must pass a collection ID (&#x60;12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), not a collection UID (&#x60;12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), in this endpoint. - - This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the &#x60;name&#x60; property). The endpoint does **not** update the entire resource. - 
        const axiosConfig = {
            method: "PUT",
            url: `/collections/${request.collectionId}/responses/${request.responseId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putCollectionsCollectionIDResponsesResponseIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutCollectionsCollectionIDResponsesResponseIDResponse);

        return responseData;
    }

    public async updateCollectionTags(request: { data: PutCollectionsCollectionIDTagsBody, collectionId: string }): Promise<PutCollectionsCollectionIDTagsResponse> {
        // Updates a collection&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body.
        const axiosConfig = {
            method: "PUT",
            url: `/collections/${request.collectionId}/tags`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putCollectionsCollectionIDTagsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutCollectionsCollectionIDTagsResponse);

        return responseData;
    }

    public async updateDetectedSecretResolutions(request: { data: PutDetectedSecretsSecretIDBody, secretId: string }): Promise<PutDetectedSecretsSecretIDResponse> {
        // Updates the resolution status of a secret detected in a workspace.
        const axiosConfig = {
            method: "PUT",
            url: `/detected-secrets/${request.secretId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putDetectedSecretsSecretIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutDetectedSecretsSecretIDResponse);

        return responseData;
    }

    public async updateEnvironment(request: { data: PutEnvironmentsEnvironmentIDBody, environmentId: string }): Promise<PutEnvironmentsEnvironmentIDResponse> {
        // Updates an environment.
        const axiosConfig = {
            method: "PUT",
            url: `/environments/${request.environmentId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putEnvironmentsEnvironmentIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutEnvironmentsEnvironmentIDResponse);

        return responseData;
    }

    public async updateMock(request: { data: PutMocksMockIDBody, mockId: string }): Promise<PutMocksMockIDResponse> {
        // Updates a mock server.
        const axiosConfig = {
            method: "PUT",
            url: `/mocks/${request.mockId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putMocksMockIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutMocksMockIDResponse);

        return responseData;
    }

    public async updateServerResponse(request: { data: PutMocksMockIDServerResponsesServerResponseIDBody, mockId: string, serverResponseId: string }): Promise<PutMocksMockIDServerResponsesServerResponseIDResponseItem[]> {
        // Updates a server response.
        const axiosConfig = {
            method: "PUT",
            url: `/mocks/${request.mockId}/server-responses/${request.serverResponseId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putMocksMockIDServerResponsesServerResponseIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutMocksMockIDServerResponsesServerResponseIDResponseItem);

        return responseData;
    }

    public async updateMonitor(request: { data: PutMonitorsMonitorIDBody, monitorId: string }): Promise<PutMonitorsMonitorIDResponse> {
        // Updates a monitor.
        const axiosConfig = {
            method: "PUT",
            url: `/monitors/${request.monitorId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putMonitorsMonitorIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutMonitorsMonitorIDResponse);

        return responseData;
    }

    public async respondElementAddRequest(request: { data: PutNetworkPrivateNetworkEntityRequestRequestIDBody, requestId: number }): Promise<PutNetworkPrivateNetworkEntityRequestRequestIDResponse> {
        // Responds to a request to add an element to the [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). Only managers can approve or deny a request. Once approved, the element will appear in the team&#x27;s Private API Network.
        const axiosConfig = {
            method: "PUT",
            url: `/network/private/network-entity/request/${request.requestId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putNetworkPrivateNetworkEntityRequestRequestIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutNetworkPrivateNetworkEntityRequestRequestIDResponse);

        return responseData;
    }

    public async putElementOrFolder(request: { data: any, elementType: string, elementId: string }): Promise<any> {
        // Updates an element or folder in your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/).
        const axiosConfig = {
            method: "PUT",
            url: `/network/private/${request.elementType}/${request.elementId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = request.data;
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = response.data;

        return responseData;
    }

    public async updateUserInformation(request: { data: PutScimV2UsersUserIDBody, userId: string }): Promise<PutScimV2UsersUserIDResponse> {
        // Updates a user&#x27;s first and last name in Postman. -  - **Note:** -  - You can only use the SCIM API to update a user&#x27;s first and last name. You cannot update any other user attributes with the API. - 
        const axiosConfig = {
            method: "PUT",
            url: `/scim/v2/Users/${request.userId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putScimV2UsersUserIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutScimV2UsersUserIDResponse);

        return responseData;
    }

    public async updateWorkspace(request: { data: PutWorkspacesWorkspaceIDBody, workspaceId: string }): Promise<PutWorkspacesWorkspaceIDResponse> {
        // Updates a workspace. -  - ### Important -  - We **deprecated** linking collections or environments between workspaces. We do **not** recommend that you do this. -  - If you have a linked collection or environment, note the following: -  - - The endpoint does **not** create a clone of a collection or environment. - - Any changes you make to a linked collection or environment changes them in **all** workspaces. - - If you delete a collection or environment linked between workspaces, the system deletes it in **all** the workspaces. - 
        const axiosConfig = {
            method: "PUT",
            url: `/workspaces/${request.workspaceId}`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putWorkspacesWorkspaceIDBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutWorkspacesWorkspaceIDResponse);

        return responseData;
    }

    public async putWorkspaceGlobalVariables(request: { data: PutWorkspacesWorkspaceIDGlobalVariablesBody, workspaceId: string }): Promise<PutWorkspacesWorkspaceIDGlobalVariablesResponse> {
        // Updates and replaces a workspace&#x27;s global [variables](https://learning.postman.com/docs/sending-requests/variables/#variable-scopes). This endpoint replaces all existing global variables with the variables you pass in the request body.
        const axiosConfig = {
            method: "PUT",
            url: `/workspaces/${request.workspaceId}/global-variables`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putWorkspacesWorkspaceIDGlobalVariablesBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutWorkspacesWorkspaceIDGlobalVariablesResponse);

        return responseData;
    }

    public async updateWorkspaceTags(request: { data: PutWorkspacesWorkspaceIDTagsBody, workspaceId: string }): Promise<PutWorkspacesWorkspaceIDTagsResponse> {
        // Updates a workspace&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body.
        const axiosConfig = {
            method: "PUT",
            url: `/workspaces/${request.workspaceId}/tags`,
            params: {},
            headers: {},
        };

        const jsonEncodableRequestBody = this.toJsonEncodable(request.data, Convert.putWorkspacesWorkspaceIDTagsBodyToJson);
        axiosConfig["data"] = jsonEncodableRequestBody;
        const response = await this.instance.request(axiosConfig);

        const responseData = this.fromJsonEncodable(response.data, Convert.toPutWorkspacesWorkspaceIDTagsResponse);

        return responseData;
    }

}

